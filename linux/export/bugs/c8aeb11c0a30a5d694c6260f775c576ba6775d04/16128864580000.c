// https://syzkaller.appspot.com/bug?id=c8aeb11c0a30a5d694c6260f775c576ba6775d04
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <sched.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/resource.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/time.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/capability.h>

#ifndef __NR_ioctl
#define __NR_ioctl 29
#endif
#ifndef __NR_mmap
#define __NR_mmap 222
#endif
#ifndef __NR_writev
#define __NR_writev 66
#endif

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

#define MAX_FDS 30

static long syz_open_dev(volatile long a0, volatile long a1, volatile long a2)
{
  if (a0 == 0xc || a0 == 0xb) {
    char buf[128];
    sprintf(buf, "/dev/%s/%d:%d", a0 == 0xc ? "char" : "block", (uint8_t)a1,
            (uint8_t)a2);
    return open(buf, O_RDWR, 0);
  } else {
    char buf[1024];
    char* hash;
    strncpy(buf, (char*)a0, sizeof(buf) - 1);
    buf[sizeof(buf) - 1] = 0;
    while ((hash = strchr(buf, '#'))) {
      *hash = '0' + (char)(a1 % 10);
      a1 /= 10;
    }
    return open(buf, a2, 0);
  }
}

static void setup_gadgetfs();
static void setup_binderfs();
static void setup_fusectl();
static void sandbox_common_mount_tmpfs(void)
{
  write_file("/proc/sys/fs/mount-max", "100000");
  if (mkdir("./syz-tmp", 0777))
    exit(1);
  if (mount("", "./syz-tmp", "tmpfs", 0, NULL))
    exit(1);
  if (mkdir("./syz-tmp/newroot", 0777))
    exit(1);
  if (mkdir("./syz-tmp/newroot/dev", 0700))
    exit(1);
  unsigned bind_mount_flags = MS_BIND | MS_REC | MS_PRIVATE;
  if (mount("/dev", "./syz-tmp/newroot/dev", NULL, bind_mount_flags, NULL))
    exit(1);
  if (mkdir("./syz-tmp/newroot/proc", 0700))
    exit(1);
  if (mount("syz-proc", "./syz-tmp/newroot/proc", "proc", 0, NULL))
    exit(1);
  if (mkdir("./syz-tmp/newroot/selinux", 0700))
    exit(1);
  const char* selinux_path = "./syz-tmp/newroot/selinux";
  if (mount("/selinux", selinux_path, NULL, bind_mount_flags, NULL)) {
    if (errno != ENOENT)
      exit(1);
    if (mount("/sys/fs/selinux", selinux_path, NULL, bind_mount_flags, NULL) &&
        errno != ENOENT)
      exit(1);
  }
  if (mkdir("./syz-tmp/newroot/sys", 0700))
    exit(1);
  if (mount("/sys", "./syz-tmp/newroot/sys", 0, bind_mount_flags, NULL))
    exit(1);
  if (mount("/sys/kernel/debug", "./syz-tmp/newroot/sys/kernel/debug", NULL,
            bind_mount_flags, NULL) &&
      errno != ENOENT)
    exit(1);
  if (mount("/sys/fs/smackfs", "./syz-tmp/newroot/sys/fs/smackfs", NULL,
            bind_mount_flags, NULL) &&
      errno != ENOENT)
    exit(1);
  if (mount("/proc/sys/fs/binfmt_misc",
            "./syz-tmp/newroot/proc/sys/fs/binfmt_misc", NULL, bind_mount_flags,
            NULL) &&
      errno != ENOENT)
    exit(1);
  if (mkdir("./syz-tmp/newroot/syz-inputs", 0700))
    exit(1);
  if (mount("/syz-inputs", "./syz-tmp/newroot/syz-inputs", NULL,
            bind_mount_flags | MS_RDONLY, NULL) &&
      errno != ENOENT)
    exit(1);
  if (mkdir("./syz-tmp/pivot", 0777))
    exit(1);
  if (syscall(SYS_pivot_root, "./syz-tmp", "./syz-tmp/pivot")) {
    if (chdir("./syz-tmp"))
      exit(1);
  } else {
    if (chdir("/"))
      exit(1);
    if (umount2("./pivot", MNT_DETACH))
      exit(1);
  }
  if (chroot("./newroot"))
    exit(1);
  if (chdir("/"))
    exit(1);
  setup_gadgetfs();
  setup_binderfs();
  setup_fusectl();
}

static void setup_gadgetfs()
{
  if (mkdir("/dev/gadgetfs", 0777)) {
  }
  if (mount("gadgetfs", "/dev/gadgetfs", "gadgetfs", 0, NULL)) {
  }
}

static void setup_fusectl()
{
  if (mount(0, "/sys/fs/fuse/connections", "fusectl", 0, 0)) {
  }
}

static void setup_binderfs()
{
  if (mkdir("/dev/binderfs", 0777)) {
  }
  if (mount("binder", "/dev/binderfs", "binder", 0, NULL)) {
  }
  if (symlink("/dev/binderfs", "./binderfs")) {
  }
}

static void loop();

static void sandbox_common()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  if (getppid() == 1)
    exit(1);
  struct rlimit rlim;
  rlim.rlim_cur = rlim.rlim_max = (200 << 20);
  setrlimit(RLIMIT_AS, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 32 << 20;
  setrlimit(RLIMIT_MEMLOCK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 136 << 20;
  setrlimit(RLIMIT_FSIZE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 1 << 20;
  setrlimit(RLIMIT_STACK, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 128 << 20;
  setrlimit(RLIMIT_CORE, &rlim);
  rlim.rlim_cur = rlim.rlim_max = 256;
  setrlimit(RLIMIT_NOFILE, &rlim);
  if (unshare(CLONE_NEWNS)) {
  }
  if (mount(NULL, "/", NULL, MS_REC | MS_PRIVATE, NULL)) {
  }
  if (unshare(CLONE_NEWIPC)) {
  }
  if (unshare(0x02000000)) {
  }
  if (unshare(CLONE_NEWUTS)) {
  }
  if (unshare(CLONE_SYSVSEM)) {
  }
  typedef struct {
    const char* name;
    const char* value;
  } sysctl_t;
  static const sysctl_t sysctls[] = {
      {"/proc/sys/kernel/shmmax", "16777216"},
      {"/proc/sys/kernel/shmall", "536870912"},
      {"/proc/sys/kernel/shmmni", "1024"},
      {"/proc/sys/kernel/msgmax", "8192"},
      {"/proc/sys/kernel/msgmni", "1024"},
      {"/proc/sys/kernel/msgmnb", "1024"},
      {"/proc/sys/kernel/sem", "1024 1048576 500 1024"},
  };
  unsigned i;
  for (i = 0; i < sizeof(sysctls) / sizeof(sysctls[0]); i++)
    write_file(sysctls[i].name, sysctls[i].value);
}

static int wait_for_loop(int pid)
{
  if (pid < 0)
    exit(1);
  int status = 0;
  while (waitpid(-1, &status, __WALL) != pid) {
  }
  return WEXITSTATUS(status);
}

static void drop_caps(void)
{
  struct __user_cap_header_struct cap_hdr = {};
  struct __user_cap_data_struct cap_data[2] = {};
  cap_hdr.version = _LINUX_CAPABILITY_VERSION_3;
  cap_hdr.pid = getpid();
  if (syscall(SYS_capget, &cap_hdr, &cap_data))
    exit(1);
  const int drop = (1 << CAP_SYS_PTRACE) | (1 << CAP_SYS_NICE);
  cap_data[0].effective &= ~drop;
  cap_data[0].permitted &= ~drop;
  cap_data[0].inheritable &= ~drop;
  if (syscall(SYS_capset, &cap_hdr, &cap_data))
    exit(1);
}

static int do_sandbox_none(void)
{
  if (unshare(CLONE_NEWPID)) {
  }
  int pid = fork();
  if (pid != 0)
    return wait_for_loop(pid);
  sandbox_common();
  drop_caps();
  if (unshare(CLONE_NEWNET)) {
  }
  write_file("/proc/sys/net/ipv4/ping_group_range", "0 65535");
  sandbox_common_mount_tmpfs();
  loop();
  exit(1);
}

static int inject_fault(int nth)
{
  int fd;
  fd = open("/proc/thread-self/fail-nth", O_RDWR);
  if (fd == -1)
    exit(1);
  char buf[16];
  sprintf(buf, "%d", nth);
  if (write(fd, buf, strlen(buf)) != (ssize_t)strlen(buf))
    exit(1);
  return fd;
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  for (int i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  write_file("/proc/self/oom_score_adj", "1000");
}

static void close_fds()
{
  for (int fd = 3; fd < MAX_FDS; fd++)
    close(fd);
}

static const char* setup_fault()
{
  int fd = open("/proc/self/make-it-fail", O_WRONLY);
  if (fd == -1)
    return "CONFIG_FAULT_INJECTION is not enabled";
  close(fd);
  fd = open("/proc/thread-self/fail-nth", O_WRONLY);
  if (fd == -1)
    return "kernel does not have systematic fault injection support";
  close(fd);
  static struct {
    const char* file;
    const char* val;
    bool fatal;
  } files[] = {
      {"/sys/kernel/debug/failslab/ignore-gfp-wait", "N", true},
      {"/sys/kernel/debug/fail_futex/ignore-private", "N", false},
      {"/sys/kernel/debug/fail_page_alloc/ignore-gfp-highmem", "N", false},
      {"/sys/kernel/debug/fail_page_alloc/ignore-gfp-wait", "N", false},
      {"/sys/kernel/debug/fail_page_alloc/min-order", "0", false},
  };
  unsigned i;
  for (i = 0; i < sizeof(files) / sizeof(files[0]); i++) {
    if (!write_file(files[i].file, files[i].val)) {
      if (files[i].fatal)
        return "failed to write fault injection file";
    }
  }
  return NULL;
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  int iter = 0;
  for (;; iter++) {
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      setup_test();
      execute_one();
      close_fds();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      sleep_ms(10);
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      if (current_time_ms() - start < 5000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
  }
}

uint64_t r[2] = {0xffffffffffffffff, 0xffffffffffffffff};

void execute_one(void)
{
  intptr_t res = 0;
  if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
  }
  res = -1;
  res = syz_open_dev(/*dev=*/0xc, /*major=*/4, /*minor=*/1);
  if (res != -1)
    r[0] = res;
  *(uint32_t*)0x400000000040 = 0;
  *(uint32_t*)0x400000000044 = 0;
  *(uint32_t*)0x400000000048 = 5;
  *(uint32_t*)0x40000000004c = 0x1d;
  *(uint32_t*)0x400000000050 = 0x200;
  *(uint64_t*)0x400000000058 = 0x400000000880;
  memcpy(
      (void*)0x400000000880,
      "\x1a\xe1\x93\x37\xaa\x15\x1f\x36\xae\x49\xbb\x3f\x8c\xb9\x5c\x5b\xf8\x40"
      "\xd4\xf1\xe5\x5e\xfa\xaf\x09\x8d\x47\xa7\x0e\xb3\x6a\x73\x09\x00\x00\x00"
      "\x00\xfd\xfd\x00\x0f\x47\x43\xf4\x90\xc5\x85\x10\x8c\x13\x31\xc7\x74\x92"
      "\x99\xa2\x5a\x70\x5f\x50\x96\xcb\x26\x8c\xbc\x60\x70\xd6\x80\xe1\xbe\x25"
      "\x07\x00\x00\x00\x05\x00\x00\x00\x47\x24\x71\xff\x55\x0c\x00\x10\x00\x00"
      "\x07\xf3\xc7\xb6\x1a\xbe\x41\x62\x25\x60\x04\xea\x8c\xa5\xe5\xb5\xf3\x79"
      "\xc6\xeb\x32\x57\xed\xa0\x8f\x7e\x69\x59\x09\x00\x00\x00\x4d\x13\x18\x4d"
      "\x38\x27\x47\xe0\x35\xb4\x72\x25\x25\xe0\x0a\xde\x86\xb4\xc6\xd1\xe1\x57"
      "\xc7\x5d\x15\xc1\xf9\x61\xeb\xc0\xa6\x4d\x7f\x2a\x73\xf8\x97\x9f\xce\xca"
      "\xca\xa6\x4f\x9b\x90\x69\xeb\xcc\x1d\x5b\x47\x1e\xdb\xc4\xf6\xc7\xf1\xb9"
      "\x8a\xe7\x4e\x90\x9a\xa6\xf2\x5b\x7f\xa7\x7b\xf9\xcd\x4e\xd3\x6d\x5c\x53"
      "\xdc\x51\x9d\x11\xc3\xcc\x1c\x22\xa3\xb8\x6c\xf3\xc6\x45\x41\x3f\x4a\xfb"
      "\xce\xa0\xc9\x9d\xed\x70\x36\x99\xd2\xbb\x6a\x4a\x66\x3b\x99\xb6\x06\x9d"
      "\xa5\xaa\xf6\x47\x85\xa5\x88\x7c\x31\x26\x1d\x4b\x9e\x57\xee\x07\x00\x00"
      "\x00\xde\xf6\xf2\x55\xca\x26\x10\x8f\x11\xf0\x20\x47\xd4\x7f\x2d\x0f\xec"
      "\x30\xf7\xe9\x24\x82\xf7\x14\x96\xe1\x84\x21\x4a\x4e\x0c\x5f\xdc\x48\xb0"
      "\xaf\x0c\x04\x78\x94\x00\x16\xd8\xf0\x99\x0a\x0e\x10\x90\xfd\x51\x53\x80"
      "\xaa\xe8\x3c\x5e\xae\xed\x33\x87\x01\x57\x4b\x64\x20\x0a\x16\xef\x28\x11"
      "\xfa\xdc\xf1\xe0\xf4\x9a\x51\x4d\xf5\x29\x06\x1e\x09\xce\x45\xe3\xda\x03"
      "\xa0\x3f\xe9\xb4\xa6\xbc\xfa\x7d\x04\x59\x4e\x4f\x6d\x07\x14\xa2\xe1\x4e"
      "\xa1\x27\xab\x37\xd6\x4a\x5e\x0d\xb6\x30\xcd\x4f\x4a\x2e\x6c\x98\x5a\x54"
      "\x2f\xf2\x0a\x9b\x21\x93\xf2\x65\xf9\x3a\x25\x8a\x88\xdd\x6c\x9d\x6a\x92"
      "\x6d\xd2\x3d\x32\x42\x58\x49\xc5\xd9\x21\x00\x07\x66\x0a\x61\x7f\x22\x13"
      "\x3b\x6c\xb5\x08\x7f\x4c\x60\x57\x94\x2a\xa1\x81\x93\x17\x2b\xd9\x95\xfa"
      "\x70\xa1\xf9\x49\xb1\x96\xf2\xe2\xa3\xc1\x75\x85\x85\x75\x71\x3b\xe5\xee"
      "\x3f\x7f\x4d\xce\xcc\x98\x12\x3f\x9d\xed\x3a\xfd\xeb\xe1\x3d\x79\xa7\xf7"
      "\xfc\xb2\x46\x9a\xe0\xac\x50\x31\x11\x40\x16\x12\xdf\x7e\xe9\x95\xf7\x4f"
      "\xb9\x7a\x63\xbf\x62\xd6\x1f\x78\xc0\x62\xf9\x59\x11\x9a\xb5\x0c\x1f\x70"
      "\x6a\x93\x01\x21\xeb\xcd\x53\xcc\xb9\x3d\x15\x81\x86\xed\x36\x07\x50\xca"
      "\x8e\x72\x81\x50\xd9\x88\x84\x4b\x9a\x5c\xff\x46\x59\x1c\xca\xff\x41\x6e"
      "\x5a\x8c\x25\xf9\x55\x5d\xa5\xca\x6f\xdf\x75\xb8\x6e\xa6\x17\x1b\x04\x6b"
      "\x85\x61\x68\xf4\x03\xb5\x25\x3a\x5c\xc3\x93\x43\x0a\x09\xa4\x48\x9a\x08"
      "\x95\x57\x1e\x59\x7a\xc8\x84\x6f\x94\x5f\xfb\x37\x2a\x88\xd3\xa2\x59\x78"
      "\xb4\x63\xdc\x96\x14\x16\xc8\x0c\x55\x77\x3f\x91\x70\x20\x75\x1e\xd5\x1c"
      "\xfd\x73\xc1\xe0\x6f\xba\xdd\x15\x6d\x56\xbe\xdc\x11\x7a\xf9\x5d\x24\x2d"
      "\x6d\xcc\xbe\x2c\xe3\x4d\xcc\xd6\x00\x5e\x94\x4a\xfa\x92\xb2\x2e\xc9\xa6"
      "\x98\x46\x9c\x6e\xdc\x06\xca\xa2\xcf\xcd\x61\x91\x26\x07\xd4\x59\xb4\xc2"
      "\x8e\xbe\xa9\x74\x5b\xcd\x46\x97\xd7\x5c\x96\x01\xfd\x33\x3d\x3c\xd7\x97"
      "\x96\x3a\x3c\x71\xb7\xcc\x5f\xdc\x75\x6d\xa8\xd9\x72\x07\x93\x6e\x5f\x53"
      "\xb5\x3b\x73\x25\x33\xc2\x72\x2e\x03\x00\x22\x93\x51\x79\x66\x61\x16\x02"
      "\xf2\x97\xde\x6f\xf5\x40\x87\x77\xb7\xa9\x3c\x45\xce\xe3\xee\x5c\x56\x01"
      "\xa4\xe9\x42\x66\xb2\x95\xea\x7a\x86\x81\x2a\x7a\xb8\x89\x6e\xc5\xea\x1b"
      "\x12\x64\x3e\x18\x44\xb1\x85\x73\x45\x28\x39\x9e\x62\xbc\xeb\x87\x00\xcc"
      "\x6c\xd4\x91\xe4\xa4\x43\x0d\x0a\x3b\xa3\x29\xa5\xa2\xfa\x17\x0f\xd0\xb1"
      "\xcc\x4b\xa8\x29\x4d\xe9\x88\xcd\x35\xdf\x2c\xd7\x34\x4a\xa8\xa9\xf3\x43"
      "\x2b\x96\xfb\x88\x9c\x02\xf4\x84\xf6\x35\xa0\xcc\x34\x66\xa3\xc2\x73\x3d"
      "\x45\xf1\x76\x93\x1b\x2d\xb1\x8d\xba\x54\x99\x1a\x95\x53\xce\xdb\x7f\x58"
      "\x57\x86\x38\x8d\x40\x42\xdb\xae\x1c\x95\xb7\x69\xe3\xd4\xe0\x36\xe8\xaf"
      "\xea\x0a\x04\xc0\x4f\x54\x2b\x15\x2c\xa1\xfd\x1f\x8e\xfe\xe6\x04\x25\xc5"
      "\xa1\x22\xfd\x1b\x90\xe9\x86\x35\x28\x4a\xbd\x9f\x21\x7d\x9e\x19\xcb\x2a"
      "\x64\xb3\x54\xc9\xd7\x95\x09\xcc\x47\xd7\x30\x51\x14\x99\x01\x48\xa7\x29"
      "\x1c\xb0\xfe\x2d\x1c\x77\x3a\x66\x64\xb6\x6a\xe0\x4a\xa6\x2c\x53\x4d\x07"
      "\x2a\xe5\x4c\x2c\xa0\xd5\x96\x2c\xc5\x89\x45\xd8\x92\x4a\xbf\xc4\xd5\xaf"
      "\x92\x24\x62\x50\x74\x30\xd8\xf2\xc1\x74\x79\xa6\x67\x8b\x0b\x37\x00\x00"
      "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
      "\x00\x00\xf8\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
      "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00",
      1024);
  inject_fault(7);
  syscall(__NR_ioctl, /*fd=*/r[0], /*cmd=*/0x4b72, /*arg=*/0x400000000040ul);
  memcpy((void*)0x400000000040, "/dev/vcsa#\000", 11);
  res = -1;
  res = syz_open_dev(/*dev=*/0x400000000040, /*id=*/1,
                     /*flags=O_CREAT|O_RDWR*/ 0x42);
  if (res != -1)
    r[1] = res;
  *(uint64_t*)0x400000000580 = 0x400000000100;
  memcpy((void*)0x400000000100, "\x5b\x6f\x19\x98", 4);
  *(uint64_t*)0x400000000588 = 3;
  *(uint64_t*)0x400000000590 = 0x4000000001c0;
  memset((void*)0x4000000001c0, 100, 1);
  *(uint64_t*)0x400000000598 = 0x3000;
  syscall(__NR_writev, /*fd=*/r[1], /*vec=*/0x400000000580ul, /*vlen=*/2ul);
}
int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x3ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul, /*fd=*/-1,
          /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x400000000000ul, /*len=*/0x1000000ul,
          /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/ 7ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul, /*fd=*/-1,
          /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x400001000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul, /*fd=*/-1,
          /*offset=*/0ul);
  const char* reason;
  (void)reason;
  if ((reason = setup_fault()))
    printf("the reproducer may not work as expected: fault injection setup "
           "failed: %s\n",
           reason);
  do_sandbox_none();
  return 0;
}
