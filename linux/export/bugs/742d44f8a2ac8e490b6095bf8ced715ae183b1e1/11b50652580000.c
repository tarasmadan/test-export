// https://syzkaller.appspot.com/bug?id=742d44f8a2ac8e490b6095bf8ced715ae183b1e1
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef __NR_bpf
#define __NR_bpf 321
#endif

#define BITMASK(bf_off, bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type, htobe, addr, val, bf_off, bf_len)               \
  *(type*)(addr) =                                                             \
      htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) |           \
            (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

uint64_t r[12] = {0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0x0,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0xffffffffffffffff,
                  0x0,
                  0x0};

int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x1ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x1000000ul,
          /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/ 7ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200001000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  const char* reason;
  (void)reason;
  intptr_t res = 0;
  if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
  }
  //  openat$tun arguments: [
  //    fd: const = 0xffffffffffffff9c (8 bytes)
  //    file: ptr[in, buffer] {
  //      buffer: {2f 64 65 76 2f 6e 65 74 2f 74 75 6e 00} (length 0xd)
  //    }
  //    flags: open_flags = 0x0 (4 bytes)
  //    mode: const = 0x0 (2 bytes)
  //  ]
  //  returns fd_tun
  memcpy((void*)0x200000000240, "/dev/net/tun\000", 13);
  res = syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul,
                /*file=*/0x200000000240ul, /*flags=*/0, /*mode=*/0);
  if (res != -1)
    r[0] = res;
  //  ioctl$TUNSETIFF arguments: [
  //    fd: fd_tun (resource)
  //    cmd: const = 0x400454ca (4 bytes)
  //    arg: ptr[in, ifreq_dev_t[devnames, flags[tun_setiff_flags, int16]]] {
  //      ifreq_dev_t[devnames, flags[tun_setiff_flags, int16]] {
  //        ifr_ifrn: buffer: {73 79 7a 6b 61 6c 6c 65 72 30 00 00 00 00 00 00}
  //        (length 0x10) elem: tun_setiff_flags = 0x7101 (2 bytes) pad = 0x0
  //        (22 bytes)
  //      }
  //    }
  //  ]
  memcpy((void*)0x200000000040, "syzkaller0\000\000\000\000\000\000", 16);
  *(uint16_t*)0x200000000050 = 0x7101;
  syscall(__NR_ioctl, /*fd=*/r[0], /*cmd=*/0x400454ca,
          /*arg=*/0x200000000040ul);
  //  socket arguments: [
  //    domain: socket_domain = 0x400000000010 (8 bytes)
  //    type: socket_type = 0x3 (8 bytes)
  //    proto: int32 = 0x0 (4 bytes)
  //  ]
  //  returns sock
  res = syscall(__NR_socket,
                /*domain=AF_NETLINK|0x400000000000*/ 0x400000000010ul,
                /*type=SOCK_RAW*/ 3ul, /*proto=*/0);
  if (res != -1)
    r[1] = res;
  //  socket$unix arguments: [
  //    domain: const = 0x1 (8 bytes)
  //    type: unix_socket_type = 0x1 (8 bytes)
  //    proto: const = 0x0 (4 bytes)
  //  ]
  //  returns sock_unix
  res = syscall(__NR_socket, /*domain=*/1ul, /*type=SOCK_STREAM*/ 1ul,
                /*proto=*/0);
  if (res != -1)
    r[2] = res;
  //  ioctl$sock_SIOCGIFINDEX arguments: [
  //    fd: sock (resource)
  //    cmd: const = 0x8933 (4 bytes)
  //    arg: ptr[out, ifreq_dev_t[devnames, ifindex]] {
  //      ifreq_dev_t[devnames, ifindex] {
  //        ifr_ifrn: buffer: {73 79 7a 6b 61 6c 6c 65 72 30 00 00 00 00 00 00}
  //        (length 0x10) elem: ifindex (resource) pad = 0x0 (20 bytes)
  //      }
  //    }
  //  ]
  memcpy((void*)0x200000000100, "syzkaller0\000\000\000\000\000\000", 16);
  res = syscall(__NR_ioctl, /*fd=*/r[2], /*cmd=*/0x8933,
                /*arg=*/0x200000000100ul);
  if (res != -1)
    r[3] = *(uint32_t*)0x200000000110;
  //  sendmsg$nl_route_sched arguments: [
  //    fd: sock_nl_route (resource)
  //    msg: ptr[in, msghdr_netlink[netlink_msg_route_sched]] {
  //      msghdr_netlink[netlink_msg_route_sched] {
  //        addr: nil
  //        addrlen: len = 0x0 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //        vec: ptr[in, iovec[in, netlink_msg_route_sched]] {
  //          iovec[in, netlink_msg_route_sched] {
  //            addr: ptr[in, netlink_msg_route_sched] {
  //              union netlink_msg_route_sched {
  //                newqdisc: netlink_msg_t[const[RTM_NEWQDISC, int16],
  //                tcmsg[AF_UNSPEC], rtm_tca_policy] {
  //                  len: len = 0x2c (4 bytes)
  //                  type: const = 0x24 (2 bytes)
  //                  flags: netlink_msg_flags = 0x4ee4e6a52ff56541 (2 bytes)
  //                  seq: int32 = 0x70bd2a (4 bytes)
  //                  pid: int32 = 0xffffffff (4 bytes)
  //                  payload: tcmsg[AF_UNSPEC] {
  //                    family: const = 0x0 (1 bytes)
  //                    tcm__pad1: const = 0x0 (1 bytes)
  //                    tcm__pad2: const = 0x0 (2 bytes)
  //                    ifindex: ifindex (resource)
  //                    tcm_handle: tcm_handle {
  //                      minor: tcm_handle_offsets = 0x0 (2 bytes)
  //                      major: tcm_handle_offsets = 0xfff1 (2 bytes)
  //                    }
  //                    tcm_parent: tcm_handle {
  //                      minor: tcm_handle_offsets = 0xffff (2 bytes)
  //                      major: tcm_handle_offsets = 0xffff (2 bytes)
  //                    }
  //                    tcm_info: tcm_handle {
  //                      minor: tcm_handle_offsets = 0xc (2 bytes)
  //                      major: tcm_handle_offsets = 0xf (2 bytes)
  //                    }
  //                  }
  //                  attrs: array[rtm_tca_policy] {
  //                    union rtm_tca_policy {
  //                      qdisc_kind_options: union qdisc_kind_options {
  //                        q_drr: nlattr_t[const[TCA_KIND, int16],
  //                        string["drr"]] {
  //                          nla_len: offsetof = 0x8 (2 bytes)
  //                          nla_type: const = 0x1 (2 bytes)
  //                          payload: buffer: {64 72 72 00} (length 0x4)
  //                          size: buffer: {} (length 0x0)
  //                        }
  //                      }
  //                    }
  //                  }
  //                }
  //              }
  //            }
  //            len: len = 0x2c (8 bytes)
  //          }
  //        }
  //        vlen: const = 0x1 (8 bytes)
  //        ctrl: const = 0x0 (8 bytes)
  //        ctrllen: const = 0x0 (8 bytes)
  //        f: send_flags = 0x8001 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //      }
  //    }
  //    f: send_flags = 0x20008850 (8 bytes)
  //  ]
  *(uint64_t*)0x2000000012c0 = 0;
  *(uint32_t*)0x2000000012c8 = 0;
  *(uint64_t*)0x2000000012d0 = 0x200000000080;
  *(uint64_t*)0x200000000080 = 0x2000000001c0;
  *(uint32_t*)0x2000000001c0 = 0x2c;
  *(uint16_t*)0x2000000001c4 = 0x24;
  *(uint16_t*)0x2000000001c6 = 0x6541;
  *(uint32_t*)0x2000000001c8 = 0x70bd2a;
  *(uint32_t*)0x2000000001cc = -1;
  *(uint8_t*)0x2000000001d0 = 0;
  *(uint8_t*)0x2000000001d1 = 0;
  *(uint16_t*)0x2000000001d2 = 0;
  *(uint32_t*)0x2000000001d4 = r[3];
  *(uint16_t*)0x2000000001d8 = 0;
  *(uint16_t*)0x2000000001da = 0xfff1;
  *(uint16_t*)0x2000000001dc = -1;
  *(uint16_t*)0x2000000001de = -1;
  *(uint16_t*)0x2000000001e0 = 0xc;
  *(uint16_t*)0x2000000001e2 = 0xf;
  *(uint16_t*)0x2000000001e4 = 8;
  *(uint16_t*)0x2000000001e6 = 1;
  memcpy((void*)0x2000000001e8, "drr\000", 4);
  *(uint64_t*)0x200000000088 = 0x2c;
  *(uint64_t*)0x2000000012d8 = 1;
  *(uint64_t*)0x2000000012e0 = 0;
  *(uint64_t*)0x2000000012e8 = 0;
  *(uint32_t*)0x2000000012f0 = 0x8001;
  syscall(__NR_sendmsg, /*fd=*/r[1], /*msg=*/0x2000000012c0ul,
          /*f=MSG_FASTOPEN|MSG_PROBE|MSG_MORE|MSG_DONTWAIT|MSG_CONFIRM*/
          0x20008850ul);
  //  socket$unix arguments: [
  //    domain: const = 0x1 (8 bytes)
  //    type: unix_socket_type = 0x1 (8 bytes)
  //    proto: const = 0x0 (4 bytes)
  //  ]
  //  returns sock_unix
  res = syscall(__NR_socket, /*domain=*/1ul, /*type=SOCK_STREAM*/ 1ul,
                /*proto=*/0);
  if (res != -1)
    r[4] = res;
  //  socket$kcm arguments: [
  //    domain: const = 0x11 (8 bytes)
  //    type: kcm_socket_type = 0x3 (8 bytes)
  //    proto: const = 0x0 (4 bytes)
  //  ]
  //  returns sock_kcm
  res = syscall(__NR_socket, /*domain=*/0x11ul, /*type=SOCK_DGRAM|0x1*/ 3ul,
                /*proto=*/0);
  if (res != -1)
    r[5] = res;
  //  openat$tun arguments: [
  //    fd: const = 0xffffffffffffff9c (8 bytes)
  //    file: ptr[in, buffer] {
  //      buffer: {2f 64 65 76 2f 6e 65 74 2f 74 75 6e 00} (length 0xd)
  //    }
  //    flags: open_flags = 0x0 (4 bytes)
  //    mode: const = 0x0 (2 bytes)
  //  ]
  //  returns fd_tun
  memcpy((void*)0x200000000400, "/dev/net/tun\000", 13);
  res = syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul,
                /*file=*/0x200000000400ul, /*flags=*/0, /*mode=*/0);
  if (res != -1)
    r[6] = res;
  //  close arguments: [
  //    fd: fd (resource)
  //  ]
  syscall(__NR_close, /*fd=*/r[6]);
  //  socket$nl_route arguments: [
  //    domain: const = 0x10 (8 bytes)
  //    type: const = 0x3 (8 bytes)
  //    proto: const = 0x0 (4 bytes)
  //  ]
  //  returns sock_nl_route
  res = syscall(__NR_socket, /*domain=*/0x10ul, /*type=*/3ul, /*proto=*/0);
  if (res != -1)
    r[7] = res;
  //  bpf$BPF_PROG_RAW_TRACEPOINT_LOAD arguments: [
  //    cmd: const = 0x5 (8 bytes)
  //    arg: ptr[in, bpf_prog_t[flags[bpf_raw_tracepoint_prog_types, int32],
  //    const[0, int32], const[0, int32], const[0, int32]]] {
  //      bpf_prog_t[flags[bpf_raw_tracepoint_prog_types, int32], const[0,
  //      int32], const[0, int32], const[0, int32]] {
  //        type: bpf_raw_tracepoint_prog_types = 0x3 (4 bytes)
  //        ninsn: bytesize8 = 0x4 (4 bytes)
  //        insns: ptr[in, bpf_instructions] {
  //          union bpf_instructions {
  //            framed: bpf_framed_program {
  //              initr0: bpf_insn_init_r0 {
  //                code: const = 0x18 (1 bytes)
  //                dst: const = 0x2 (0 bytes)
  //                src: const = 0x0 (1 bytes)
  //                off: const = 0x0 (2 bytes)
  //                imm: int32 = 0xffffffff (4 bytes)
  //                code2: const = 0x0 (1 bytes)
  //                regs2: const = 0x0 (1 bytes)
  //                off2: const = 0x0 (2 bytes)
  //                imm2: int32 = 0x80 (4 bytes)
  //              }
  //              body: array[bpf_insn] {
  //                union bpf_insn {
  //                  call: bpf_insn_call_helper_t[int32[0:__BPF_FUNC_MAX_ID]] {
  //                    code: const = 0x85 (1 bytes)
  //                    regs: const = 0x0 (1 bytes)
  //                    off: const = 0x0 (2 bytes)
  //                    func: int32 = 0x17 (4 bytes)
  //                  }
  //                }
  //              }
  //              exit: bpf_insn_exit {
  //                code: const = 0x95 (1 bytes)
  //                regs: const = 0x0 (1 bytes)
  //                off: const = 0x0 (2 bytes)
  //                imm: const = 0x0 (4 bytes)
  //              }
  //            }
  //          }
  //        }
  //        license: ptr[in, buffer] {
  //          buffer: {47 50 4c 00} (length 0x4)
  //        }
  //        loglev: int32 = 0x0 (4 bytes)
  //        logsize: len = 0x0 (4 bytes)
  //        log: nil
  //        kern_version: bpf_kern_version = 0x41000 (4 bytes)
  //        flags: bpf_prog_load_flags = 0x20 (4 bytes)
  //        prog_name: buffer: {00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
  //        (length 0x10) prog_ifindex: ifindex (resource) expected_attach_type:
  //        const = 0x0 (4 bytes) btf_fd: fd_btf (resource) func_info_rec_size:
  //        const = 0x8 (4 bytes) func_info: nil func_info_cnt: len = 0x0 (4
  //        bytes) line_info_rec_size: const = 0x10 (4 bytes) line_info: nil
  //        line_info_cnt: len = 0x0 (4 bytes)
  //        attach_btf_id: const = 0x0 (4 bytes)
  //        attach_prog_fd: const = 0x0 (4 bytes)
  //        core_relo_cnt: len = 0x0 (4 bytes)
  //        fd_array: nil
  //        core_relos: nil
  //        core_relo_rec_size: const = 0x10 (4 bytes)
  //        log_true_size: int32 = 0x0 (4 bytes)
  //        prog_token_fd: union
  //        _bpf_prog_t[flags[bpf_raw_tracepoint_prog_types, int32], const[0,
  //        int32], const[0, int32], const[0, int32]]_prog_token_fd_wrapper {
  //          void: buffer: {} (length 0x0)
  //        }
  //        pad: union _bpf_prog_t[flags[bpf_raw_tracepoint_prog_types, int32],
  //        const[0, int32], const[0, int32], const[0, int32]]_pad_wrapper {
  //          value: const = 0x0 (4 bytes)
  //        }
  //      }
  //    }
  //    size: len = 0x94 (8 bytes)
  //  ]
  //  returns fd_bpf_prog_raw_tracepoint
  *(uint32_t*)0x200000000340 = 3;
  *(uint32_t*)0x200000000344 = 4;
  *(uint64_t*)0x200000000348 = 0x2000000008c0;
  *(uint8_t*)0x2000000008c0 = 0x18;
  STORE_BY_BITMASK(uint8_t, , 0x2000000008c1, 2, 0, 4);
  STORE_BY_BITMASK(uint8_t, , 0x2000000008c1, 0, 4, 4);
  *(uint16_t*)0x2000000008c2 = 0;
  *(uint32_t*)0x2000000008c4 = -1;
  *(uint8_t*)0x2000000008c8 = 0;
  *(uint8_t*)0x2000000008c9 = 0;
  *(uint16_t*)0x2000000008ca = 0;
  *(uint32_t*)0x2000000008cc = 0x80;
  *(uint8_t*)0x2000000008d0 = 0x85;
  *(uint8_t*)0x2000000008d1 = 0;
  *(uint16_t*)0x2000000008d2 = 0;
  *(uint32_t*)0x2000000008d4 = 0x17;
  *(uint8_t*)0x2000000008d8 = 0x95;
  *(uint8_t*)0x2000000008d9 = 0;
  *(uint16_t*)0x2000000008da = 0;
  *(uint32_t*)0x2000000008dc = 0;
  *(uint64_t*)0x200000000350 = 0x200000000040;
  memcpy((void*)0x200000000040, "GPL\000", 4);
  *(uint32_t*)0x200000000358 = 0;
  *(uint32_t*)0x20000000035c = 0;
  *(uint64_t*)0x200000000360 = 0;
  *(uint32_t*)0x200000000368 = 0x41000;
  *(uint32_t*)0x20000000036c = 0x20;
  memset((void*)0x200000000370, 0, 16);
  *(uint32_t*)0x200000000380 = 0;
  *(uint32_t*)0x200000000384 = 0;
  *(uint32_t*)0x200000000388 = -1;
  *(uint32_t*)0x20000000038c = 8;
  *(uint64_t*)0x200000000390 = 0;
  *(uint32_t*)0x200000000398 = 0;
  *(uint32_t*)0x20000000039c = 0x10;
  *(uint64_t*)0x2000000003a0 = 0;
  *(uint32_t*)0x2000000003a8 = 0;
  *(uint32_t*)0x2000000003ac = 0;
  *(uint32_t*)0x2000000003b0 = 0;
  *(uint32_t*)0x2000000003b4 = 0;
  *(uint64_t*)0x2000000003b8 = 0;
  *(uint64_t*)0x2000000003c0 = 0;
  *(uint32_t*)0x2000000003c8 = 0x10;
  *(uint32_t*)0x2000000003cc = 0;
  *(uint32_t*)0x2000000003d0 = 0;
  res =
      syscall(__NR_bpf, /*cmd=*/5ul, /*arg=*/0x200000000340ul, /*size=*/0x94ul);
  if (res != -1)
    r[8] = res;
  //  socket arguments: [
  //    domain: socket_domain = 0x400000000010 (8 bytes)
  //    type: socket_type = 0x3 (8 bytes)
  //    proto: int32 = 0x0 (4 bytes)
  //  ]
  //  returns sock
  res = syscall(__NR_socket,
                /*domain=AF_NETLINK|0x400000000000*/ 0x400000000010ul,
                /*type=SOCK_RAW*/ 3ul, /*proto=*/0);
  if (res != -1)
    r[9] = res;
  //  ioctl$sock_SIOCGIFINDEX arguments: [
  //    fd: sock (resource)
  //    cmd: const = 0x8933 (4 bytes)
  //    arg: ptr[out, ifreq_dev_t[devnames, ifindex]] {
  //      ifreq_dev_t[devnames, ifindex] {
  //        ifr_ifrn: buffer: {73 79 7a 6b 61 6c 6c 65 72 30 00 00 00 00 00 00}
  //        (length 0x10) elem: ifindex (resource) pad = 0x0 (20 bytes)
  //      }
  //    }
  //  ]
  memcpy((void*)0x200000000380, "syzkaller0\000\000\000\000\000\000", 16);
  res = syscall(__NR_ioctl, /*fd=*/r[9], /*cmd=*/0x8933,
                /*arg=*/0x200000000380ul);
  if (res != -1)
    r[10] = *(uint32_t*)0x200000000390;
  //  sendmsg$nl_route_sched arguments: [
  //    fd: sock_nl_route (resource)
  //    msg: ptr[in, msghdr_netlink[netlink_msg_route_sched]] {
  //      msghdr_netlink[netlink_msg_route_sched] {
  //        addr: nil
  //        addrlen: len = 0x0 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //        vec: ptr[in, iovec[in, netlink_msg_route_sched]] {
  //          iovec[in, netlink_msg_route_sched] {
  //            addr: ptr[in, netlink_msg_route_sched] {
  //              union netlink_msg_route_sched {
  //                newtfilter: netlink_msg_t[const[RTM_NEWTFILTER, int16],
  //                tcmsg[AF_UNSPEC], filter_policy] {
  //                  len: len = 0x38 (4 bytes)
  //                  type: const = 0x2c (2 bytes)
  //                  flags: netlink_msg_flags = 0xd23 (2 bytes)
  //                  seq: int32 = 0x70bd22 (4 bytes)
  //                  pid: int32 = 0x2 (4 bytes)
  //                  payload: tcmsg[AF_UNSPEC] {
  //                    family: const = 0x0 (1 bytes)
  //                    tcm__pad1: const = 0x0 (1 bytes)
  //                    tcm__pad2: const = 0x0 (2 bytes)
  //                    ifindex: ifindex (resource)
  //                    tcm_handle: tcm_handle {
  //                      minor: tcm_handle_offsets = 0x0 (2 bytes)
  //                      major: tcm_handle_offsets = 0x2400 (2 bytes)
  //                    }
  //                    tcm_parent: tcm_handle {
  //                      minor: tcm_handle_offsets = 0x0 (2 bytes)
  //                      major: tcm_handle_offsets = 0x0 (2 bytes)
  //                    }
  //                    tcm_info: tcm_handle {
  //                      minor: tcm_handle_offsets = 0x8 (2 bytes)
  //                      major: tcm_handle_offsets = 0x4 (2 bytes)
  //                    }
  //                  }
  //                  attrs: array[filter_policy] {
  //                    union filter_policy {
  //                      filter_kind_options: union filter_kind_options {
  //                        f_bpf: tca_kind_options_t["bpf", array[bpf_policy]]
  //                        {
  //                          TCA_KIND: nlattr_t[const[TCA_KIND, int16],
  //                          string["bpf"]] {
  //                            nla_len: offsetof = 0x8 (2 bytes)
  //                            nla_type: const = 0x1 (2 bytes)
  //                            payload: buffer: {62 70 66 00} (length 0x4)
  //                            size: buffer: {} (length 0x0)
  //                          }
  //                          TCA_OPTIONS: nlattr_t[const[TCA_OPTIONS, int16],
  //                          array[bpf_policy]] {
  //                            nla_len: offsetof = 0xc (2 bytes)
  //                            nla_type: const = 0x2 (2 bytes)
  //                            payload: array[bpf_policy] {
  //                              union bpf_policy {
  //                                TCA_BPF_FD: nlattr_t[const[TCA_BPF_FD,
  //                                int16], fd_bpf_prog] {
  //                                  nla_len: offsetof = 0x8 (2 bytes)
  //                                  nla_type: const = 0x6 (2 bytes)
  //                                  payload: fd_bpf_prog (resource)
  //                                  size: buffer: {} (length 0x0)
  //                                }
  //                              }
  //                            }
  //                            size: buffer: {} (length 0x0)
  //                          }
  //                        }
  //                      }
  //                    }
  //                  }
  //                }
  //              }
  //            }
  //            len: len = 0x38 (8 bytes)
  //          }
  //        }
  //        vlen: const = 0x1 (8 bytes)
  //        ctrl: const = 0x0 (8 bytes)
  //        ctrllen: const = 0x0 (8 bytes)
  //        f: send_flags = 0x4084 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //      }
  //    }
  //    f: send_flags = 0x8000 (8 bytes)
  //  ]
  *(uint64_t*)0x200000000140 = 0;
  *(uint32_t*)0x200000000148 = 0;
  *(uint64_t*)0x200000000150 = 0x2000000001c0;
  *(uint64_t*)0x2000000001c0 = 0x2000000000c0;
  *(uint32_t*)0x2000000000c0 = 0x38;
  *(uint16_t*)0x2000000000c4 = 0x2c;
  *(uint16_t*)0x2000000000c6 = 0xd23;
  *(uint32_t*)0x2000000000c8 = 0x70bd22;
  *(uint32_t*)0x2000000000cc = 2;
  *(uint8_t*)0x2000000000d0 = 0;
  *(uint8_t*)0x2000000000d1 = 0;
  *(uint16_t*)0x2000000000d2 = 0;
  *(uint32_t*)0x2000000000d4 = r[10];
  *(uint16_t*)0x2000000000d8 = 0;
  *(uint16_t*)0x2000000000da = 0x2400;
  *(uint16_t*)0x2000000000dc = 0;
  *(uint16_t*)0x2000000000de = 0;
  *(uint16_t*)0x2000000000e0 = 8;
  *(uint16_t*)0x2000000000e2 = 4;
  *(uint16_t*)0x2000000000e4 = 8;
  *(uint16_t*)0x2000000000e6 = 1;
  memcpy((void*)0x2000000000e8, "bpf\000", 4);
  *(uint16_t*)0x2000000000ec = 0xc;
  *(uint16_t*)0x2000000000ee = 2;
  *(uint16_t*)0x2000000000f0 = 8;
  *(uint16_t*)0x2000000000f2 = 6;
  *(uint32_t*)0x2000000000f4 = r[8];
  *(uint64_t*)0x2000000001c8 = 0x38;
  *(uint64_t*)0x200000000158 = 1;
  *(uint64_t*)0x200000000160 = 0;
  *(uint64_t*)0x200000000168 = 0;
  *(uint32_t*)0x200000000170 = 0x4084;
  syscall(__NR_sendmsg, /*fd=*/r[7], /*msg=*/0x200000000140ul,
          /*f=MSG_MORE*/ 0x8000ul);
  //  ioctl$SIOCSIFHWADDR arguments: [
  //    fd: fd_tun (resource)
  //    cmd: const = 0x8914 (4 bytes)
  //    arg: ptr[in, ifreq_dev_t[devnames, mac_addr]] {
  //      ifreq_dev_t[devnames, mac_addr] {
  //        ifr_ifrn: buffer: {73 79 7a 6b 61 6c 6c 65 72 30 00 00 00 00 00 00}
  //        (length 0x10) elem: union mac_addr {
  //          multicast: buffer: {bb bb bb bb bb bb} (length 0x6)
  //        }
  //        pad = 0x0 (18 bytes)
  //      }
  //    }
  //  ]
  memcpy((void*)0x200000002280, "syzkaller0\000\000\000\000\000\000", 16);
  memset((void*)0x200000002290, 187, 6);
  syscall(__NR_ioctl, /*fd=*/r[6], /*cmd=*/0x8914, /*arg=*/0x200000002280ul);
  //  ioctl$sock_SIOCGIFINDEX arguments: [
  //    fd: sock (resource)
  //    cmd: const = 0x8933 (4 bytes)
  //    arg: ptr[out, ifreq_dev_t[devnames, ifindex]] {
  //      ifreq_dev_t[devnames, ifindex] {
  //        ifr_ifrn: buffer: {73 79 7a 6b 61 6c 6c 65 72 30 00 00 00 00 00 00}
  //        (length 0x10) elem: ifindex (resource) pad = 0x0 (20 bytes)
  //      }
  //    }
  //  ]
  memcpy((void*)0x200000000100, "syzkaller0\000\000\000\000\000\000", 16);
  res = syscall(__NR_ioctl, /*fd=*/r[4], /*cmd=*/0x8933,
                /*arg=*/0x200000000100ul);
  if (res != -1)
    r[11] = *(uint32_t*)0x200000000110;
  //  setsockopt$sock_attach_bpf arguments: [
  //    fd: sock (resource)
  //    level: const = 0x107 (4 bytes)
  //    optname: const = 0xf (4 bytes)
  //    optval: ptr[in, fd_bpf_prog] {
  //      fd_bpf_prog (resource)
  //    }
  //    optlen: len = 0x56 (8 bytes)
  //  ]
  *(uint32_t*)0x200000000600 = -1;
  syscall(__NR_setsockopt, /*fd=*/r[5], /*level=*/0x107, /*optname=*/0xf,
          /*optval=*/0x200000000600ul, /*optlen=*/0x56ul);
  //  sendmsg$kcm arguments: [
  //    fd: sock_kcm (resource)
  //    msg: ptr[in, send_msghdr] {
  //      send_msghdr {
  //        msg_name: ptr[in, sockaddr_storage] {
  //          union sockaddr_storage {
  //            xdp: sockaddr_xdp {
  //              sxdp_family: const = 0x2c (2 bytes)
  //              sxdp_flags: sxdp_flags = 0x0 (2 bytes)
  //              sxdp_ifindex: ifindex (resource)
  //              sxdp_queue_id: int32 = 0x3e (4 bytes)
  //              sxdp_shared_umem_fd: const = 0x0 (4 bytes)
  //            }
  //          }
  //        }
  //        msg_namelen: len = 0x80 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //        msg_iov: ptr[in, array[iovec[in, array[int8]]]] {
  //          array[iovec[in, array[int8]]] {
  //            iovec[in, array[int8]] {
  //              addr: ptr[in, buffer] {
  //                buffer: {27 03 02 00 00 02 14 00 0e 00 00 2f b9 6d ff ff 11
  //                44 ee 16 3c dd cb 00 00 00 00 00 00 00 00 00 00 00 00 00 00
  //                00} (length 0x26)
  //              }
  //              len: len = 0x26 (8 bytes)
  //            }
  //            iovec[in, array[int8]] {
  //              addr: ptr[in, buffer] {
  //                buffer: {f0 58 fe 7d ad 77 7f 8f} (length 0x8)
  //              }
  //              len: len = 0x300 (8 bytes)
  //            }
  //          }
  //        }
  //        msg_iovlen: len = 0x2 (8 bytes)
  //        msg_control: nil
  //        msg_controllen: bytesize = 0x0 (8 bytes)
  //        msg_flags: const = 0x0 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //      }
  //    }
  //    f: send_flags = 0x5 (8 bytes)
  //  ]
  *(uint64_t*)0x200000000280 = 0x200000000380;
  *(uint16_t*)0x200000000380 = 0x2c;
  *(uint16_t*)0x200000000382 = 0;
  *(uint32_t*)0x200000000384 = r[11];
  *(uint32_t*)0x200000000388 = 0x3e;
  *(uint32_t*)0x20000000038c = 0;
  *(uint32_t*)0x200000000288 = 0x80;
  *(uint64_t*)0x200000000290 = 0x2000000001c0;
  *(uint64_t*)0x2000000001c0 = 0x200000000180;
  memcpy((void*)0x200000000180,
         "\x27\x03\x02\x00\x00\x02\x14\x00\x0e\x00\x00\x2f\xb9\x6d\xff\xff\x11"
         "\x44\xee\x16\x3c\xdd\xcb\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
         "\x00\x00\x00\x00",
         38);
  *(uint64_t*)0x2000000001c8 = 0x26;
  *(uint64_t*)0x2000000001d0 = 0x2000000004c0;
  memcpy((void*)0x2000000004c0, "\xf0\x58\xfe\x7d\xad\x77\x7f\x8f", 8);
  *(uint64_t*)0x2000000001d8 = 0x300;
  *(uint64_t*)0x200000000298 = 2;
  *(uint64_t*)0x2000000002a0 = 0;
  *(uint64_t*)0x2000000002a8 = 0;
  *(uint32_t*)0x2000000002b0 = 0;
  syscall(__NR_sendmsg, /*fd=*/r[5], /*msg=*/0x200000000280ul,
          /*f=MSG_OOB|MSG_DONTROUTE*/ 5ul);
  return 0;
}
