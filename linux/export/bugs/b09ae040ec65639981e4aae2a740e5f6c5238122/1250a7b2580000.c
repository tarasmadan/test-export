// https://syzkaller.appspot.com/bug?id=b09ae040ec65639981e4aae2a740e5f6c5238122
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#define BITMASK(bf_off, bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type, htobe, addr, val, bf_off, bf_len)               \
  *(type*)(addr) =                                                             \
      htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) |           \
            (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static int inject_fault(int nth)
{
  int fd;
  fd = open("/proc/thread-self/fail-nth", O_RDWR);
  if (fd == -1)
    exit(1);
  char buf[16];
  sprintf(buf, "%d", nth);
  if (write(fd, buf, strlen(buf)) != (ssize_t)strlen(buf))
    exit(1);
  return fd;
}

static const char* setup_fault()
{
  int fd = open("/proc/self/make-it-fail", O_WRONLY);
  if (fd == -1)
    return "CONFIG_FAULT_INJECTION is not enabled";
  close(fd);
  fd = open("/proc/thread-self/fail-nth", O_WRONLY);
  if (fd == -1)
    return "kernel does not have systematic fault injection support";
  close(fd);
  static struct {
    const char* file;
    const char* val;
    bool fatal;
  } files[] = {
      {"/sys/kernel/debug/failslab/ignore-gfp-wait", "N", true},
      {"/sys/kernel/debug/fail_futex/ignore-private", "N", false},
      {"/sys/kernel/debug/fail_page_alloc/ignore-gfp-highmem", "N", false},
      {"/sys/kernel/debug/fail_page_alloc/ignore-gfp-wait", "N", false},
      {"/sys/kernel/debug/fail_page_alloc/min-order", "0", false},
  };
  unsigned i;
  for (i = 0; i < sizeof(files) / sizeof(files[0]); i++) {
    if (!write_file(files[i].file, files[i].val)) {
      if (files[i].fatal)
        return "failed to write fault injection file";
    }
  }
  return NULL;
}

uint64_t r[1] = {0xffffffffffffffff};

int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x1ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x1000000ul,
          /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/ 7ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200001000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  const char* reason;
  (void)reason;
  if ((reason = setup_fault()))
    printf("the reproducer may not work as expected: fault injection setup "
           "failed: %s\n",
           reason);
  intptr_t res = 0;
  if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
  }
  //  socket$nl_netfilter arguments: [
  //    domain: const = 0x10 (8 bytes)
  //    type: const = 0x3 (8 bytes)
  //    proto: const = 0xc (4 bytes)
  //  ]
  //  returns sock_nl_netfilter
  res = syscall(__NR_socket, /*domain=*/0x10ul, /*type=*/3ul, /*proto=*/0xc);
  if (res != -1)
    r[0] = res;
  //  sendmsg$NFT_BATCH arguments: [
  //    fd: sock_nl_netfilter (resource)
  //    msg: ptr[in, msghdr_netlink[nft_batch_msg]] {
  //      msghdr_netlink[nft_batch_msg] {
  //        addr: nil
  //        addrlen: len = 0x0 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //        vec: ptr[in, iovec[in, nft_batch_msg]] {
  //          iovec[in, nft_batch_msg] {
  //            addr: ptr[inout, array[ANYUNION]] {
  //              array[ANYUNION] {
  //                union ANYUNION {
  //                  ANYBLOB: buffer: {14 00 00 00 10 00 01 00 00 00 00 00 00
  //                  00 00 00 05 00 00 0a 28 00 00 00 00 0a 03 00 00 00 00 00
  //                  00 00 00 00 0a 00 00 07 08 00 02 40 00 00 00 02 09 00 01
  //                  00 73 79 7a 31 00 00 00 00 2c 00 00 00 03 0a 01 01 00 00
  //                  00 00 00 00 00 00 0a 00 00 07 09 00 01 00 73 79 7a 31 00
  //                  00 00 00 09 00 03 00 73 79 7a 32 00 00 00 00 14 00 00 00
  //                  11 00 01} (length 0x6f)
  //                }
  //              }
  //            }
  //            len: len = 0x7c (8 bytes)
  //          }
  //        }
  //        vlen: const = 0x1 (8 bytes)
  //        ctrl: const = 0x0 (8 bytes)
  //        ctrllen: const = 0x0 (8 bytes)
  //        f: send_flags = 0x4000 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //      }
  //    }
  //    f: send_flags = 0x0 (8 bytes)
  //  ]
  *(uint64_t*)0x2000000000c0 = 0;
  *(uint32_t*)0x2000000000c8 = 0;
  *(uint64_t*)0x2000000000d0 = 0x200000000080;
  *(uint64_t*)0x200000000080 = 0x200000000240;
  memcpy((void*)0x200000000240,
         "\x14\x00\x00\x00\x10\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x05"
         "\x00\x00\x0a\x28\x00\x00\x00\x00\x0a\x03\x00\x00\x00\x00\x00\x00\x00"
         "\x00\x00\x0a\x00\x00\x07\x08\x00\x02\x40\x00\x00\x00\x02\x09\x00\x01"
         "\x00\x73\x79\x7a\x31\x00\x00\x00\x00\x2c\x00\x00\x00\x03\x0a\x01\x01"
         "\x00\x00\x00\x00\x00\x00\x00\x00\x0a\x00\x00\x07\x09\x00\x01\x00\x73"
         "\x79\x7a\x31\x00\x00\x00\x00\x09\x00\x03\x00\x73\x79\x7a\x32\x00\x00"
         "\x00\x00\x14\x00\x00\x00\x11\x00\x01",
         111);
  *(uint64_t*)0x200000000088 = 0x7c;
  *(uint64_t*)0x2000000000d8 = 1;
  *(uint64_t*)0x2000000000e0 = 0;
  *(uint64_t*)0x2000000000e8 = 0;
  *(uint32_t*)0x2000000000f0 = 0x4000;
  syscall(__NR_sendmsg, /*fd=*/r[0], /*msg=*/0x2000000000c0ul, /*f=*/0ul);
  //  sendmsg$NFT_BATCH arguments: [
  //    fd: sock_nl_netfilter (resource)
  //    msg: ptr[in, msghdr_netlink[nft_batch_msg]] {
  //      msghdr_netlink[nft_batch_msg] {
  //        addr: nil
  //        addrlen: len = 0x0 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //        vec: ptr[in, iovec[in, nft_batch_msg]] {
  //          iovec[in, nft_batch_msg] {
  //            addr: ptr[in, nft_batch_msg] {
  //              nft_batch_msg {
  //                begin: nft_nlmsghdr[NFNL_MSG_BATCH_BEGIN] {
  //                  nlmsg_len: len = 0x14 (4 bytes)
  //                  nlmsg_type: const = 0x10 (2 bytes)
  //                  nlmsg_flags: const = 0x1 (2 bytes)
  //                  nlmsg_seq: const = 0x0 (4 bytes)
  //                  nlmsg_pid: const = 0x2000000 (4 bytes)
  //                  hdr: nfgenmsg_nft {
  //                    nfgen_family: families = 0x7 (1 bytes)
  //                    version: const = 0x0 (1 bytes)
  //                    res_id: const = 0xa (2 bytes)
  //                  }
  //                }
  //                msgs: array[nft_batch_message] {
  //                  union nft_batch_message {
  //                    NFT_MSG_NEWSET:
  //                    netlink_msg_netfilter_tt[NFNL_SUBSYS_NFTABLES,
  //                    NFT_MSG_NEWSET, array[nft_set_policy]] {
  //                      len: len = 0x4c (4 bytes)
  //                      type: const = 0x9 (1 bytes)
  //                      subsys: const = 0xa (1 bytes)
  //                      flags: netlink_netfilter_msg_flags = 0x43f (2 bytes)
  //                      seq: const = 0x0 (4 bytes)
  //                      pid: const = 0x0 (4 bytes)
  //                      hdr: nfgenmsg {
  //                        nfgen_family: nfproto = 0xa (1 bytes)
  //                        version: const = 0x0 (1 bytes)
  //                        res_id: int16be = 0x4 (2 bytes)
  //                      }
  //                      attrs: array[nft_set_policy] {
  //                        union nft_set_policy {
  //                          NFTA_SET_TABLE: nlattr_t[const[NFTA_SET_TABLE,
  //                          int16], string[nft_table_name]] {
  //                            nla_len: offsetof = 0x9 (2 bytes)
  //                            nla_type: const = 0x1 (2 bytes)
  //                            payload: buffer: {73 79 7a 31 00} (length 0x5)
  //                            size: buffer: {} (length 0x0)
  //                            pad = 0x0 (3 bytes)
  //                          }
  //                        }
  //                        union nft_set_policy {
  //                          NFTA_SET_ID: nlattr_tt[const[NFTA_SET_ID,
  //                          int16:14], 1, 0, nft_set_id] {
  //                            nla_len: offsetof = 0x8 (2 bytes)
  //                            nla_type: const = 0xa (1 bytes)
  //                            NLA_F_NET_BYTEORDER: const = 0x1 (0 bytes)
  //                            NLA_F_NESTED: const = 0x0 (1 bytes)
  //                            payload: int32be = 0xfffffffc (4 bytes)
  //                            size: buffer: {} (length 0x0)
  //                          }
  //                        }
  //                        union nft_set_policy {
  //                          NFTA_SET_KEY_LEN:
  //                          nlattr_tt[const[NFTA_SET_KEY_LEN, int16:14], 1, 0,
  //                          int32be[1:NFT_DATA_VALUE_MAXLEN]] {
  //                            nla_len: offsetof = 0x8 (2 bytes)
  //                            nla_type: const = 0x5 (1 bytes)
  //                            NLA_F_NET_BYTEORDER: const = 0x1 (0 bytes)
  //                            NLA_F_NESTED: const = 0x0 (1 bytes)
  //                            payload: int32be = 0x2 (4 bytes)
  //                            size: buffer: {} (length 0x0)
  //                          }
  //                        }
  //                        union nft_set_policy {
  //                          NFTA_SET_NAME: nlattr_t[const[NFTA_SET_NAME,
  //                          int16], string[nft_set_name]] {
  //                            nla_len: offsetof = 0x9 (2 bytes)
  //                            nla_type: const = 0x2 (2 bytes)
  //                            payload: buffer: {73 79 7a 31 00} (length 0x5)
  //                            size: buffer: {} (length 0x0)
  //                            pad = 0x0 (3 bytes)
  //                          }
  //                        }
  //                        union nft_set_policy {
  //                          NFTA_SET_FLAGS: nlattr_tt[const[NFTA_SET_FLAGS,
  //                          int16:14], 1, 0, flags[nft_set_flags, int32be]] {
  //                            nla_len: offsetof = 0x8 (2 bytes)
  //                            nla_type: const = 0x3 (1 bytes)
  //                            NLA_F_NET_BYTEORDER: const = 0x1 (0 bytes)
  //                            NLA_F_NESTED: const = 0x0 (1 bytes)
  //                            payload: nft_set_flags = 0x11c (4 bytes)
  //                            size: buffer: {} (length 0x0)
  //                          }
  //                        }
  //                        union nft_set_policy {
  //                          NFTA_SET_DATA_TYPE:
  //                          nlattr_tt[const[NFTA_SET_DATA_TYPE, int16:14], 1,
  //                          0, flags[nft_data_types, int32be]] {
  //                            nla_len: offsetof = 0x8 (2 bytes)
  //                            nla_type: const = 0x6 (1 bytes)
  //                            NLA_F_NET_BYTEORDER: const = 0x1 (0 bytes)
  //                            NLA_F_NESTED: const = 0x0 (1 bytes)
  //                            payload: nft_data_types = 0xffffff00 (4 bytes)
  //                            size: buffer: {} (length 0x0)
  //                          }
  //                        }
  //                      }
  //                    }
  //                  }
  //                }
  //                end: nft_nlmsghdr[NFNL_MSG_BATCH_END] {
  //                  nlmsg_len: len = 0x14 (4 bytes)
  //                  nlmsg_type: const = 0x11 (2 bytes)
  //                  nlmsg_flags: const = 0x1 (2 bytes)
  //                  nlmsg_seq: const = 0x0 (4 bytes)
  //                  nlmsg_pid: const = 0x0 (4 bytes)
  //                  hdr: nfgenmsg_nft {
  //                    nfgen_family: families = 0x7 (1 bytes)
  //                    version: const = 0x0 (1 bytes)
  //                    res_id: const = 0xa (2 bytes)
  //                  }
  //                }
  //              }
  //            }
  //            len: len = 0x74 (8 bytes)
  //          }
  //        }
  //        vlen: const = 0x1 (8 bytes)
  //        ctrl: const = 0x0 (8 bytes)
  //        ctrllen: const = 0x0 (8 bytes)
  //        f: send_flags = 0x4000850 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //      }
  //    }
  //    f: send_flags = 0x0 (8 bytes)
  //  ]
  *(uint64_t*)0x200000009b40 = 0;
  *(uint32_t*)0x200000009b48 = 0;
  *(uint64_t*)0x200000009b50 = 0x200000009b00;
  *(uint64_t*)0x200000009b00 = 0x200000000380;
  *(uint32_t*)0x200000000380 = 0x14;
  *(uint16_t*)0x200000000384 = 0x10;
  *(uint16_t*)0x200000000386 = 1;
  *(uint32_t*)0x200000000388 = 0;
  *(uint32_t*)0x20000000038c = 0x2000000;
  *(uint8_t*)0x200000000390 = 7;
  *(uint8_t*)0x200000000391 = 0;
  *(uint16_t*)0x200000000392 = htobe16(0xa);
  *(uint32_t*)0x200000000394 = 0x4c;
  *(uint8_t*)0x200000000398 = 9;
  *(uint8_t*)0x200000000399 = 0xa;
  *(uint16_t*)0x20000000039a = 0x43f;
  *(uint32_t*)0x20000000039c = 0;
  *(uint32_t*)0x2000000003a0 = 0;
  *(uint8_t*)0x2000000003a4 = 0xa;
  *(uint8_t*)0x2000000003a5 = 0;
  *(uint16_t*)0x2000000003a6 = htobe16(4);
  *(uint16_t*)0x2000000003a8 = 9;
  *(uint16_t*)0x2000000003aa = 1;
  memcpy((void*)0x2000000003ac, "syz1\000", 5);
  *(uint16_t*)0x2000000003b4 = 8;
  STORE_BY_BITMASK(uint16_t, , 0x2000000003b6, 0xa, 0, 14);
  STORE_BY_BITMASK(uint16_t, , 0x2000000003b7, 1, 6, 1);
  STORE_BY_BITMASK(uint16_t, , 0x2000000003b7, 0, 7, 1);
  *(uint32_t*)0x2000000003b8 = htobe32(0xfffffffc);
  *(uint16_t*)0x2000000003bc = 8;
  STORE_BY_BITMASK(uint16_t, , 0x2000000003be, 5, 0, 14);
  STORE_BY_BITMASK(uint16_t, , 0x2000000003bf, 1, 6, 1);
  STORE_BY_BITMASK(uint16_t, , 0x2000000003bf, 0, 7, 1);
  *(uint32_t*)0x2000000003c0 = htobe32(2);
  *(uint16_t*)0x2000000003c4 = 9;
  *(uint16_t*)0x2000000003c6 = 2;
  memcpy((void*)0x2000000003c8, "syz1\000", 5);
  *(uint16_t*)0x2000000003d0 = 8;
  STORE_BY_BITMASK(uint16_t, , 0x2000000003d2, 3, 0, 14);
  STORE_BY_BITMASK(uint16_t, , 0x2000000003d3, 1, 6, 1);
  STORE_BY_BITMASK(uint16_t, , 0x2000000003d3, 0, 7, 1);
  *(uint32_t*)0x2000000003d4 = htobe32(0x11c);
  *(uint16_t*)0x2000000003d8 = 8;
  STORE_BY_BITMASK(uint16_t, , 0x2000000003da, 6, 0, 14);
  STORE_BY_BITMASK(uint16_t, , 0x2000000003db, 1, 6, 1);
  STORE_BY_BITMASK(uint16_t, , 0x2000000003db, 0, 7, 1);
  *(uint32_t*)0x2000000003dc = htobe32(0xffffff00);
  *(uint32_t*)0x2000000003e0 = 0x14;
  *(uint16_t*)0x2000000003e4 = 0x11;
  *(uint16_t*)0x2000000003e6 = 1;
  *(uint32_t*)0x2000000003e8 = 0;
  *(uint32_t*)0x2000000003ec = 0;
  *(uint8_t*)0x2000000003f0 = 7;
  *(uint8_t*)0x2000000003f1 = 0;
  *(uint16_t*)0x2000000003f2 = htobe16(0xa);
  *(uint64_t*)0x200000009b08 = 0x74;
  *(uint64_t*)0x200000009b58 = 1;
  *(uint64_t*)0x200000009b60 = 0;
  *(uint64_t*)0x200000009b68 = 0;
  *(uint32_t*)0x200000009b70 = 0x4000850;
  syscall(__NR_sendmsg, /*fd=*/r[0], /*msg=*/0x200000009b40ul, /*f=*/0ul);
  //  close arguments: [
  //    fd: fd (resource)
  //  ]
  inject_fault(1);
  syscall(__NR_close, /*fd=*/3);
  return 0;
}
