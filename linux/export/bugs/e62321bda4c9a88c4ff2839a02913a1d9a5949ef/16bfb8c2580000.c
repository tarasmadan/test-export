// https://syzkaller.appspot.com/bug?id=e62321bda4c9a88c4ff2839a02913a1d9a5949ef
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#ifndef __NR_fsconfig
#define __NR_fsconfig 431
#endif
#ifndef __NR_fsmount
#define __NR_fsmount 432
#endif
#ifndef __NR_fsopen
#define __NR_fsopen 430
#endif
#ifndef __NR_fspick
#define __NR_fspick 433
#endif

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  for (int i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  write_file("/proc/self/oom_score_adj", "1000");
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  int iter = 0;
  for (;; iter++) {
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      sleep_ms(10);
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      if (current_time_ms() - start < 5000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
  }
}

uint64_t r[3] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff};

void execute_one(void)
{
  intptr_t res = 0;
  if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
  }
  //  fsopen arguments: [
  //    type: ptr[in, buffer] {
  //      buffer: {6d 71 75 65 75 65 00} (length 0x7)
  //    }
  //    flags: fsopen_flags = 0x0 (8 bytes)
  //  ]
  //  returns fd_fscontext
  memcpy((void*)0x200000000140, "mqueue\000", 7);
  res = syscall(__NR_fsopen, /*type=*/0x200000000140ul, /*flags=*/0ul);
  if (res != -1)
    r[0] = res;
  //  fsconfig$FSCONFIG_CMD_CREATE arguments: [
  //    fd: fd_fscontext (resource)
  //    cmd: const = 0x6 (8 bytes)
  //    key: const = 0x0 (8 bytes)
  //    value: const = 0x0 (8 bytes)
  //    aux: const = 0x0 (8 bytes)
  //  ]
  syscall(__NR_fsconfig, /*fd=*/r[0], /*cmd=*/6ul, /*key=*/0ul, /*value=*/0ul,
          /*aux=*/0ul);
  //  fsmount arguments: [
  //    fs_fd: fd_fscontext (resource)
  //    flags: fsmount_flags = 0x0 (8 bytes)
  //    attr_flags: fsmount_attr_flags = 0x0 (8 bytes)
  //  ]
  //  returns fd
  res =
      syscall(__NR_fsmount, /*fs_fd=*/r[0], /*flags=*/0ul, /*attr_flags=*/0ul);
  if (res != -1)
    r[1] = res;
  //  fchdir arguments: [
  //    fd: fd (resource)
  //  ]
  syscall(__NR_fchdir, /*fd=*/r[1]);
  //  fspick arguments: [
  //    dfd: fd_dir (resource)
  //    path: ptr[in, buffer] {
  //      buffer: {2e 00} (length 0x2)
  //    }
  //    flags: fspick_flags = 0x0 (8 bytes)
  //  ]
  //  returns fd_fscontext
  memcpy((void*)0x200000000000, ".\000", 2);
  res = syscall(__NR_fspick, /*dfd=*/0xffffff9c, /*path=*/0x200000000000ul,
                /*flags=*/0ul);
  if (res != -1)
    r[2] = res;
  //  fsconfig$FSCONFIG_SET_FLAG arguments: [
  //    fd: fd_fscontext (resource)
  //    cmd: const = 0x0 (8 bytes)
  //    key: ptr[in, buffer] {
  //      buffer: {72 6f 00} (length 0x3)
  //    }
  //    value: const = 0x0 (8 bytes)
  //    aux: const = 0x0 (8 bytes)
  //  ]
  memcpy((void*)0x200000000040, "ro\000", 3);
  syscall(__NR_fsconfig, /*fd=*/r[2], /*cmd=*/0ul, /*key=*/0x200000000040ul,
          /*value=*/0ul, /*aux=*/0ul);
  //  fsconfig$FSCONFIG_CMD_RECONFIGURE arguments: [
  //    fd: fd_fscontext (resource)
  //    cmd: const = 0x7 (8 bytes)
  //    key: const = 0x0 (8 bytes)
  //    value: const = 0x0 (8 bytes)
  //    aux: const = 0x0 (8 bytes)
  //  ]
  syscall(__NR_fsconfig, /*fd=*/r[2], /*cmd=*/7ul, /*key=*/0ul, /*value=*/0ul,
          /*aux=*/0ul);
  //  mq_open arguments: [
  //    name: ptr[in, buffer] {
  //      buffer: {21 7f 00 ca 00 00 00 0c 00 00 01 45 21 54 ed 6e 75 78 02 c7
  //      12 ec ca 37 bc 1f 53 1c 05 79 91 e5 9a 4c a9 75 08 00 00 00 a0 70 43
  //      19 9b 0b 59 18 36 a4 e7 1e 67 7b 60 fa f3 6e 8f 49 6a 36 66 fb 13 2d
  //      67 19 28 61 36 18 e2 34 6e 7a 83 77 38 ff fb 83 0c 9a da c5 77 8e 6f
  //      02 a3 c1 83 91 c6 fd 8c c4 73 03 16 a4 2b ce 7c 5e 98 4b 5f 30 8a b0
  //      ff 7e 1e d9 32 b4 72 d8 e7} (length 0x79)
  //    }
  //    flags: mq_open_flags = 0x40 (8 bytes)
  //    mode: open_mode = 0x110 (8 bytes)
  //    attr: nil
  //  ]
  //  returns fd_mq
  memcpy((void*)0x2000000004c0,
         "!\177\000\312\000\000\000\f\000\000\001E!"
         "T\355nux\002\307\022\354\3127\274\037S\034\005y\221\345\232L\251u\b"
         "\000\000\000\240pC\031\233\vY\0306\244\347\036g{`"
         "\372\363n\217Ij6f\373\023-g\031("
         "a6\030\3424nz\203w8\377\373\203\f\232\332\305w\216o\002\243\301\203"
         "\221\306\375\214\304s\003\026\244+\316|^\230K_0\212\260\377~"
         "\036\3312\264r\330\347",
         121);
  syscall(__NR_mq_open, /*name=*/0x2000000004c0ul, /*flags=O_CREAT*/ 0x40ul,
          /*mode=S_IWGRP|S_IRUSR*/ 0x110ul, /*attr=*/0ul);
}
int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x1ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x1000000ul,
          /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/ 7ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200001000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  const char* reason;
  (void)reason;
  loop();
  return 0;
}
