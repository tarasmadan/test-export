// https://syzkaller.appspot.com/bug?id=dfe934fe24fd6d2ce493572ac41ad4502fa4bd52
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/prctl.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  for (int i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  write_file("/proc/self/oom_score_adj", "1000");
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  int iter = 0;
  for (;; iter++) {
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      sleep_ms(10);
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      if (current_time_ms() - start < 5000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
  }
}

uint64_t r[4] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff,
                 0xffffffffffffffff};

void execute_one(void)
{
  intptr_t res = 0;
  if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
  }
  //  openat$udambuf arguments: [
  //    fd: const = 0xffffffffffffff9c (8 bytes)
  //    file: ptr[in, buffer] {
  //      buffer: {2f 64 65 76 2f 75 64 6d 61 62 75 66 00} (length 0xd)
  //    }
  //    flags: const = 0x2 (4 bytes)
  //  ]
  //  returns fd_udambuf
  memcpy((void*)0x2000000001c0, "/dev/udmabuf\000", 13);
  res = syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul,
                /*file=*/0x2000000001c0ul, /*flags=*/2, 0);
  if (res != -1)
    r[0] = res;
  //  memfd_create arguments: [
  //    name: ptr[in, buffer] {
  //      buffer: {79 10 35 fb f7 75 83 25 3a 72 c2 b9 78 a4 71 c1 ea 5f 8c 5a
  //      37 e7 61 9b 11 78 0e a1 cf 1a 98 53 37 c9 00 00 00 00 00 00 07 00 00
  //      00 00 00 00 04 87 39 a2 34 a9 61 6d de b2 d3 cb 5a 4a 6f 61 c4 1a 63
  //      42 aa c1 fb 20 51 d4 f4 01 a5 32 e2 44 47 d4 bd 7b 9f a9 97 9b 40 db
  //      00 62 e1 62 72 b6 ea 37 e3 10 ff c2 9d 0d 32 9e 8e 04 73 57 1b b7 b3
  //      a2 c9 26 40 ca da dc e2 2f 97 58 ac 08 b0 c2 3c 80 45 1a bc c7 57 da
  //      39 56 73 41 af c6 cf e1 a1 b5 4d a2 85 a6 79 c4 4a f1 f7 fc 44 95 e3
  //      eb 0f 3c 91 b0 a8 9e 6f eb 46 28 9d 4c 01 76 52 6b aa 63 42 04 a7 49
  //      0b 86 45 5a 96 d5 14 4f 44 5c e8 52 e4 cd ec cc d1 0f 72 65 e8 36 cd
  //      eb c4 24 98 06 4a d6 64 44 8d 5f 55 60 6a 69 7b ab 97 af 3b 6c 1f af
  //      b3 38 55 cb fa b3 6a 92 0c 81 a0 a2 2d 67 08 99 0e 8d 8d 16 d9 77 5c
  //      f8 ce b0 6a 9d 27 93 ef 1d a0 48 cd bd d9 af 12 24 8d 16 25 8b 00 d5
  //      f3 5c 00 be 5d 45 74 ad 2a ec 6a 02 c8 c4 0c 04 99 f6 fc} (length
  //      0x124)
  //    }
  //    flags: memfd_flags = 0x2 (8 bytes)
  //  ]
  //  returns fd_memfd
  memcpy((void*)0x2000000003c0,
         "y\0205\373\367u\203%:r\302\271x\244q\301\352_"
         "\214Z7\347a\233\021x\016\241\317\032\230S7\311\000\000\000\000\000"
         "\000\a\000\000\000\000\000\000\004\2079\2424\251am\336\262\323\313ZJo"
         "a\304\032cB\252\301\373 "
         "Q\324\364\001\2452\342DG\324\275{\237\251\227\233@"
         "\333\000b\341br\266\3527\343\020\377\302\235\r2\236\216\004sW\033\267"
         "\263\242\311&@\312\332\334\342/"
         "\227X\254\b\260\302<"
         "\200E\032\274\307W\3329VsA\257\306\317\341\241\265M\242\205\246y\304J"
         "\361\367\374D\225\343\353\017<\221\260\250\236o\353F("
         "\235L\001vRk\252cB\004\247I\v\206EZ\226\325\024OD\\\350R\344\315\354"
         "\314\321\017re\3506\315\353\304$\230\006J\326dD\215_U`ji{"
         "\253\227\257;l\037\257\2638U\313\372\263j\222\f\201\240\242-"
         "g\b\231\016\215\215\026\331w\\\370\316\260j\235\'\223\357\035\240H"
         "\315\275\331\257\022$\215\026%\213\000\325\363\\\000\276]Et\255*"
         "\354j\002\310\304\f\004\231\366\374",
         292);
  res = syscall(__NR_memfd_create, /*name=*/0x2000000003c0ul,
                /*flags=MFD_ALLOW_SEALING*/ 2ul);
  if (res != -1)
    r[1] = res;
  //  ftruncate arguments: [
  //    fd: fd (resource)
  //    len: intptr = 0xffff (8 bytes)
  //  ]
  syscall(__NR_ftruncate, /*fd=*/r[1], /*len=*/0xfffful);
  //  fcntl$addseals arguments: [
  //    fd: fd (resource)
  //    cmd: const = 0x409 (8 bytes)
  //    seals: seal_types = 0x7 (8 bytes)
  //  ]
  syscall(__NR_fcntl, /*fd=*/r[1], /*cmd=*/0x409ul,
          /*seals=F_SEAL_GROW|F_SEAL_SHRINK|F_SEAL_SEAL*/ 7ul);
  //  ioctl$UDMABUF_CREATE arguments: [
  //    fd: fd_udambuf (resource)
  //    cmd: const = 0x40187542 (4 bytes)
  //    arg: ptr[in, udmabuf_create] {
  //      udmabuf_create {
  //        memfd: fd_memfd (resource)
  //        flags: int32 = 0x0 (4 bytes)
  //        offset: udmabuf_offset_size = 0x0 (8 bytes)
  //        size: udmabuf_offset_size = 0x1000 (8 bytes)
  //      }
  //    }
  //  ]
  //  returns fd_dma_buf
  *(uint32_t*)0x2000000002c0 = r[1];
  *(uint32_t*)0x2000000002c4 = 0;
  *(uint64_t*)0x2000000002c8 = 0;
  *(uint64_t*)0x2000000002d0 = 0x1000;
  res = syscall(__NR_ioctl, /*fd=*/r[0], /*cmd=*/0x40187542,
                /*arg=*/0x2000000002c0ul);
  if (res != -1)
    r[2] = res;
  //  fcntl$dupfd arguments: [
  //    fd: fd (resource)
  //    cmd: fcntl_dupfd = 0x0 (8 bytes)
  //    arg: fd (resource)
  //  ]
  //  returns fd
  res = syscall(__NR_fcntl, /*fd=*/r[2], /*cmd=*/0ul, /*arg=*/r[2]);
  if (res != -1)
    r[3] = res;
  //  mmap arguments: [
  //    addr: VMA[0x1000]
  //    len: len = 0x1000 (8 bytes)
  //    prot: mmap_prot = 0x2 (8 bytes)
  //    flags: mmap_flags = 0x8013 (8 bytes)
  //    fd: fd (resource)
  //    offset: intptr = 0x0 (8 bytes)
  //  ]
  syscall(__NR_mmap, /*addr=*/0x200000ffd000ul, /*len=*/0x1000ul,
          /*prot=PROT_WRITE*/ 2ul,
          /*flags=MAP_SHARED_VALIDATE|MAP_POPULATE|MAP_FIXED*/ 0x8013ul,
          /*fd=*/r[3], /*offset=*/0ul);
}
int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x1ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x1000000ul,
          /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/ 7ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200001000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  const char* reason;
  (void)reason;
  loop();
  return 0;
}
