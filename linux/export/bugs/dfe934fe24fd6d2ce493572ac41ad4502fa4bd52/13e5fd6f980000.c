// https://syzkaller.appspot.com/bug?id=dfe934fe24fd6d2ce493572ac41ad4502fa4bd52
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef __NR_memfd_create
#define __NR_memfd_create 319
#endif

uint64_t r[3] = {0xffffffffffffffff, 0xffffffffffffffff, 0xffffffffffffffff};

int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x1ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x1000000ul,
          /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/ 7ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200001000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  const char* reason;
  (void)reason;
  intptr_t res = 0;
  if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
  }
  //  openat$udambuf arguments: [
  //    fd: const = 0xffffffffffffff9c (8 bytes)
  //    file: ptr[in, buffer] {
  //      buffer: {2f 64 65 76 2f 75 64 6d 61 62 75 66 00} (length 0xd)
  //    }
  //    flags: const = 0x2 (4 bytes)
  //  ]
  //  returns fd_udambuf
  memcpy((void*)0x200000000100, "/dev/udmabuf\000", 13);
  res = syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul,
                /*file=*/0x200000000100ul, /*flags=*/2, 0);
  if (res != -1)
    r[0] = res;
  //  memfd_create arguments: [
  //    name: ptr[in, buffer] {
  //      buffer: {79 10 35 fb f7 75 83 25 3a 72 c2 b9 78 a4 71 c1 ea 5f 8c 5a
  //      37 e7 61 de 6e 4a eb 87 9b 11 78 0e a1 cf 1a 98 53 37 c9 00 00 00 00
  //      00 00 07 00 00 00 00 00 00 04 87 39 a2 34 a9 61 6d de b2 d3 cb 5a 4a
  //      6f 61 c4 1a 63 42 aa c1 fb 20 51 d4 f4 01 a5 32 e2 44 47 d4 bd 7b 9f
  //      a9 97 9b 40 db 00 62 e1 62 72 b6 00 38 e3 10 ff c2 9d 0d 32 9e 8e 04
  //      73 57 1b b7 b3 a2 c9 26 40 ca da dc e2 2f 97 58 ac 08 b0 c2 3c 80 45
  //      1a bc c7 57 da 39 56 73 41 af c6 cf e1 a1 b5 4d a2 85 a6 79 c4 4a f1
  //      f7 fc 44 95 e3 eb c7 bc 91 b0 a8 9e 6f eb 46 28 9d 4c 01 76 52 6b aa
  //      63 42 14 4f 44 5c e8 52 e4 cd ec cc d1 0f 72 65 e8 36 cd eb c4 24 98
  //      06 4a d6 64 44 8d 5f 55 60 6a 69 7b ab 97 af 3b 6c 1f af b3 38 14 cb
  //      fa b3 6a 92 0c e0 81 a0 a2 2d 67 08 99 0e 8d 8d 16 d9 77 5c f0 ce b0
  //      6a 9d 27 93 ef 1d a0 48 d9 bd d9 af 12 00 00 00 00 00 00 00 00 00}
  //      (length 0x110)
  //    }
  //    flags: memfd_flags = 0x2 (8 bytes)
  //  ]
  //  returns fd_memfd
  memcpy((void*)0x200000000340,
         "y\0205\373\367u\203%:r\302\271x\244q\301\352_"
         "\214Z7\347a\336nJ\353\207\233\021x\016\241\317\032\230S7\311\000\000"
         "\000\000\000\000\a\000\000\000\000\000\000\004\2079\2424\251am\336"
         "\262\323\313ZJoa\304\032cB\252\301\373 "
         "Q\324\364\001\2452\342DG\324\275{\237\251\227\233@"
         "\333\000b\341br\266\0008\343\020\377\302\235\r2\236\216\004sW\033\267"
         "\263\242\311&@\312\332\334\342/"
         "\227X\254\b\260\302<"
         "\200E\032\274\307W\3329VsA\257\306\317\341\241\265M\242\205\246y\304J"
         "\361\367\374D\225\343\353\307\274\221\260\250\236o\353F("
         "\235L\001vRk\252cB\024OD\\\350R\344\315\354\314\321\017re\3506\315"
         "\353\304$\230\006J\326dD\215_U`ji{\253\227\257;"
         "l\037\257\2638\024\313\372\263j\222\f\340\201\240\242-"
         "g\b\231\016\215\215\026\331w\\\360\316\260j\235\'\223\357\035\240H"
         "\331\275\331\257\022\000\000\000\000\000\000\000\000\000",
         272);
  res = syscall(__NR_memfd_create, /*name=*/0x200000000340ul,
                /*flags=MFD_ALLOW_SEALING*/ 2ul);
  if (res != -1)
    r[1] = res;
  //  ftruncate arguments: [
  //    fd: fd (resource)
  //    len: intptr = 0xffff (8 bytes)
  //  ]
  syscall(__NR_ftruncate, /*fd=*/r[1], /*len=*/0xfffful);
  //  fcntl$addseals arguments: [
  //    fd: fd (resource)
  //    cmd: const = 0x409 (8 bytes)
  //    seals: seal_types = 0x7 (8 bytes)
  //  ]
  syscall(__NR_fcntl, /*fd=*/r[1], /*cmd=*/0x409ul,
          /*seals=F_SEAL_GROW|F_SEAL_SHRINK|F_SEAL_SEAL*/ 7ul);
  //  ioctl$UDMABUF_CREATE arguments: [
  //    fd: fd_udambuf (resource)
  //    cmd: const = 0x40187542 (4 bytes)
  //    arg: ptr[in, udmabuf_create] {
  //      udmabuf_create {
  //        memfd: fd_memfd (resource)
  //        flags: int32 = 0x1 (4 bytes)
  //        offset: udmabuf_offset_size = 0x0 (8 bytes)
  //        size: udmabuf_offset_size = 0x4000 (8 bytes)
  //      }
  //    }
  //  ]
  //  returns fd_dma_buf
  *(uint32_t*)0x200000000140 = r[1];
  *(uint32_t*)0x200000000144 = 1;
  *(uint64_t*)0x200000000148 = 0;
  *(uint64_t*)0x200000000150 = 0x4000;
  res = syscall(__NR_ioctl, /*fd=*/r[0], /*cmd=*/0x40187542,
                /*arg=*/0x200000000140ul);
  if (res != -1)
    r[2] = res;
  //  mmap arguments: [
  //    addr: VMA[0x3000]
  //    len: len = 0x3000 (8 bytes)
  //    prot: mmap_prot = 0x3000007 (8 bytes)
  //    flags: mmap_flags = 0x11 (8 bytes)
  //    fd: fd (resource)
  //    offset: intptr = 0x0 (8 bytes)
  //  ]
  syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x3000ul,
          /*prot=PROT_GROWSUP|PROT_GROWSDOWN|PROT_WRITE|PROT_READ|PROT_EXEC*/
          0x3000007ul, /*flags=MAP_FIXED|MAP_SHARED*/ 0x11ul, /*fd=*/r[2],
          /*offset=*/0ul);
  return 0;
}
