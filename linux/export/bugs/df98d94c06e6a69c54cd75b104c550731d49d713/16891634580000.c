// https://syzkaller.appspot.com/bug?id=df98d94c06e6a69c54cd75b104c550731d49d713
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <arpa/inet.h>
#include <dirent.h>
#include <endian.h>
#include <errno.h>
#include <fcntl.h>
#include <net/if.h>
#include <netinet/in.h>
#include <pthread.h>
#include <setjmp.h>
#include <signal.h>
#include <stdarg.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/ioctl.h>
#include <sys/mount.h>
#include <sys/prctl.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <time.h>
#include <unistd.h>

#include <linux/futex.h>
#include <linux/genetlink.h>
#include <linux/if_addr.h>
#include <linux/if_link.h>
#include <linux/in6.h>
#include <linux/neighbour.h>
#include <linux/net.h>
#include <linux/netlink.h>
#include <linux/rtnetlink.h>
#include <linux/usb/ch9.h>
#include <linux/veth.h>

static unsigned long long procid;

static __thread int clone_ongoing;
static __thread int skip_segv;
static __thread jmp_buf segv_env;

static void segv_handler(int sig, siginfo_t* info, void* ctx)
{
  if (__atomic_load_n(&clone_ongoing, __ATOMIC_RELAXED) != 0) {
    exit(sig);
  }
  uintptr_t addr = (uintptr_t)info->si_addr;
  const uintptr_t prog_start = 1 << 20;
  const uintptr_t prog_end = 100 << 20;
  int skip = __atomic_load_n(&skip_segv, __ATOMIC_RELAXED) != 0;
  int valid = addr < prog_start || addr > prog_end;
  if (skip && valid) {
    _longjmp(segv_env, 1);
  }
  exit(sig);
}

static void install_segv_handler(void)
{
  struct sigaction sa;
  memset(&sa, 0, sizeof(sa));
  sa.sa_handler = SIG_IGN;
  syscall(SYS_rt_sigaction, 0x20, &sa, NULL, 8);
  syscall(SYS_rt_sigaction, 0x21, &sa, NULL, 8);
  memset(&sa, 0, sizeof(sa));
  sa.sa_sigaction = segv_handler;
  sa.sa_flags = SA_NODEFER | SA_SIGINFO;
  sigaction(SIGSEGV, &sa, NULL);
  sigaction(SIGBUS, &sa, NULL);
}

#define NONFAILING(...)                                                        \
  ({                                                                           \
    int ok = 1;                                                                \
    __atomic_fetch_add(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    if (_setjmp(segv_env) == 0) {                                              \
      __VA_ARGS__;                                                             \
    } else                                                                     \
      ok = 0;                                                                  \
    __atomic_fetch_sub(&skip_segv, 1, __ATOMIC_SEQ_CST);                       \
    ok;                                                                        \
  })

static void sleep_ms(uint64_t ms)
{
  usleep(ms * 1000);
}

static uint64_t current_time_ms(void)
{
  struct timespec ts;
  if (clock_gettime(CLOCK_MONOTONIC, &ts))
    exit(1);
  return (uint64_t)ts.tv_sec * 1000 + (uint64_t)ts.tv_nsec / 1000000;
}

static void use_temporary_dir(void)
{
  char tmpdir_template[] = "./syzkaller.XXXXXX";
  char* tmpdir = mkdtemp(tmpdir_template);
  if (!tmpdir)
    exit(1);
  if (chmod(tmpdir, 0777))
    exit(1);
  if (chdir(tmpdir))
    exit(1);
}

static void thread_start(void* (*fn)(void*), void* arg)
{
  pthread_t th;
  pthread_attr_t attr;
  pthread_attr_init(&attr);
  pthread_attr_setstacksize(&attr, 128 << 10);
  int i = 0;
  for (; i < 100; i++) {
    if (pthread_create(&th, &attr, fn, arg) == 0) {
      pthread_attr_destroy(&attr);
      return;
    }
    if (errno == EAGAIN) {
      usleep(50);
      continue;
    }
    break;
  }
  exit(1);
}

typedef struct {
  int state;
} event_t;

static void event_init(event_t* ev)
{
  ev->state = 0;
}

static void event_reset(event_t* ev)
{
  ev->state = 0;
}

static void event_set(event_t* ev)
{
  if (ev->state)
    exit(1);
  __atomic_store_n(&ev->state, 1, __ATOMIC_RELEASE);
  syscall(SYS_futex, &ev->state, FUTEX_WAKE | FUTEX_PRIVATE_FLAG, 1000000);
}

static void event_wait(event_t* ev)
{
  while (!__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, 0);
}

static int event_isset(event_t* ev)
{
  return __atomic_load_n(&ev->state, __ATOMIC_ACQUIRE);
}

static int event_timedwait(event_t* ev, uint64_t timeout)
{
  uint64_t start = current_time_ms();
  uint64_t now = start;
  for (;;) {
    uint64_t remain = timeout - (now - start);
    struct timespec ts;
    ts.tv_sec = remain / 1000;
    ts.tv_nsec = (remain % 1000) * 1000 * 1000;
    syscall(SYS_futex, &ev->state, FUTEX_WAIT | FUTEX_PRIVATE_FLAG, 0, &ts);
    if (__atomic_load_n(&ev->state, __ATOMIC_ACQUIRE))
      return 1;
    now = current_time_ms();
    if (now - start > timeout)
      return 0;
  }
}

static bool write_file(const char* file, const char* what, ...)
{
  char buf[1024];
  va_list args;
  va_start(args, what);
  vsnprintf(buf, sizeof(buf), what, args);
  va_end(args);
  buf[sizeof(buf) - 1] = 0;
  int len = strlen(buf);
  int fd = open(file, O_WRONLY | O_CLOEXEC);
  if (fd == -1)
    return false;
  if (write(fd, buf, len) != len) {
    int err = errno;
    close(fd);
    errno = err;
    return false;
  }
  close(fd);
  return true;
}

struct nlmsg {
  char* pos;
  int nesting;
  struct nlattr* nested[8];
  char buf[4096];
};

static void netlink_init(struct nlmsg* nlmsg, int typ, int flags,
                         const void* data, int size)
{
  memset(nlmsg, 0, sizeof(*nlmsg));
  struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
  hdr->nlmsg_type = typ;
  hdr->nlmsg_flags = NLM_F_REQUEST | NLM_F_ACK | flags;
  memcpy(hdr + 1, data, size);
  nlmsg->pos = (char*)(hdr + 1) + NLMSG_ALIGN(size);
}

static void netlink_attr(struct nlmsg* nlmsg, int typ, const void* data,
                         int size)
{
  struct nlattr* attr = (struct nlattr*)nlmsg->pos;
  attr->nla_len = sizeof(*attr) + size;
  attr->nla_type = typ;
  if (size > 0)
    memcpy(attr + 1, data, size);
  nlmsg->pos += NLMSG_ALIGN(attr->nla_len);
}

static int netlink_send_ext(struct nlmsg* nlmsg, int sock, uint16_t reply_type,
                            int* reply_len, bool dofail)
{
  if (nlmsg->pos > nlmsg->buf + sizeof(nlmsg->buf) || nlmsg->nesting)
    exit(1);
  struct nlmsghdr* hdr = (struct nlmsghdr*)nlmsg->buf;
  hdr->nlmsg_len = nlmsg->pos - nlmsg->buf;
  struct sockaddr_nl addr;
  memset(&addr, 0, sizeof(addr));
  addr.nl_family = AF_NETLINK;
  ssize_t n = sendto(sock, nlmsg->buf, hdr->nlmsg_len, 0,
                     (struct sockaddr*)&addr, sizeof(addr));
  if (n != (ssize_t)hdr->nlmsg_len) {
    if (dofail)
      exit(1);
    return -1;
  }
  n = recv(sock, nlmsg->buf, sizeof(nlmsg->buf), 0);
  if (reply_len)
    *reply_len = 0;
  if (n < 0) {
    if (dofail)
      exit(1);
    return -1;
  }
  if (n < (ssize_t)sizeof(struct nlmsghdr)) {
    errno = EINVAL;
    if (dofail)
      exit(1);
    return -1;
  }
  if (hdr->nlmsg_type == NLMSG_DONE)
    return 0;
  if (reply_len && hdr->nlmsg_type == reply_type) {
    *reply_len = n;
    return 0;
  }
  if (n < (ssize_t)(sizeof(struct nlmsghdr) + sizeof(struct nlmsgerr))) {
    errno = EINVAL;
    if (dofail)
      exit(1);
    return -1;
  }
  if (hdr->nlmsg_type != NLMSG_ERROR) {
    errno = EINVAL;
    if (dofail)
      exit(1);
    return -1;
  }
  errno = -((struct nlmsgerr*)(hdr + 1))->error;
  return -errno;
}

static int netlink_query_family_id(struct nlmsg* nlmsg, int sock,
                                   const char* family_name, bool dofail)
{
  struct genlmsghdr genlhdr;
  memset(&genlhdr, 0, sizeof(genlhdr));
  genlhdr.cmd = CTRL_CMD_GETFAMILY;
  netlink_init(nlmsg, GENL_ID_CTRL, 0, &genlhdr, sizeof(genlhdr));
  netlink_attr(nlmsg, CTRL_ATTR_FAMILY_NAME, family_name,
               strnlen(family_name, GENL_NAMSIZ - 1) + 1);
  int n = 0;
  int err = netlink_send_ext(nlmsg, sock, GENL_ID_CTRL, &n, dofail);
  if (err < 0) {
    return -1;
  }
  uint16_t id = 0;
  struct nlattr* attr = (struct nlattr*)(nlmsg->buf + NLMSG_HDRLEN +
                                         NLMSG_ALIGN(sizeof(genlhdr)));
  for (; (char*)attr < nlmsg->buf + n;
       attr = (struct nlattr*)((char*)attr + NLMSG_ALIGN(attr->nla_len))) {
    if (attr->nla_type == CTRL_ATTR_FAMILY_ID) {
      id = *(uint16_t*)(attr + 1);
      break;
    }
  }
  if (!id) {
    errno = EINVAL;
    return -1;
  }
  recv(sock, nlmsg->buf, sizeof(nlmsg->buf), 0);
  return id;
}

#define MAX_FDS 30

#define USB_MAX_IFACE_NUM 4
#define USB_MAX_EP_NUM 32
#define USB_MAX_FDS 6

struct usb_endpoint_index {
  struct usb_endpoint_descriptor desc;
  int handle;
};

struct usb_iface_index {
  struct usb_interface_descriptor* iface;
  uint8_t bInterfaceNumber;
  uint8_t bAlternateSetting;
  uint8_t bInterfaceClass;
  struct usb_endpoint_index eps[USB_MAX_EP_NUM];
  int eps_num;
};

struct usb_device_index {
  struct usb_device_descriptor* dev;
  struct usb_config_descriptor* config;
  uint8_t bDeviceClass;
  uint8_t bMaxPower;
  int config_length;
  struct usb_iface_index ifaces[USB_MAX_IFACE_NUM];
  int ifaces_num;
  int iface_cur;
};

struct usb_info {
  int fd;
  struct usb_device_index index;
};

static struct usb_info usb_devices[USB_MAX_FDS];

static struct usb_device_index* lookup_usb_index(int fd)
{
  for (int i = 0; i < USB_MAX_FDS; i++) {
    if (__atomic_load_n(&usb_devices[i].fd, __ATOMIC_ACQUIRE) == fd)
      return &usb_devices[i].index;
  }
  return NULL;
}

static int usb_devices_num;

static bool parse_usb_descriptor(const char* buffer, size_t length,
                                 struct usb_device_index* index)
{
  if (length < sizeof(*index->dev) + sizeof(*index->config))
    return false;
  memset(index, 0, sizeof(*index));
  index->dev = (struct usb_device_descriptor*)buffer;
  index->config = (struct usb_config_descriptor*)(buffer + sizeof(*index->dev));
  index->bDeviceClass = index->dev->bDeviceClass;
  index->bMaxPower = index->config->bMaxPower;
  index->config_length = length - sizeof(*index->dev);
  index->iface_cur = -1;
  size_t offset = 0;
  while (true) {
    if (offset + 1 >= length)
      break;
    uint8_t desc_length = buffer[offset];
    uint8_t desc_type = buffer[offset + 1];
    if (desc_length <= 2)
      break;
    if (offset + desc_length > length)
      break;
    if (desc_type == USB_DT_INTERFACE &&
        index->ifaces_num < USB_MAX_IFACE_NUM) {
      struct usb_interface_descriptor* iface =
          (struct usb_interface_descriptor*)(buffer + offset);
      index->ifaces[index->ifaces_num].iface = iface;
      index->ifaces[index->ifaces_num].bInterfaceNumber =
          iface->bInterfaceNumber;
      index->ifaces[index->ifaces_num].bAlternateSetting =
          iface->bAlternateSetting;
      index->ifaces[index->ifaces_num].bInterfaceClass = iface->bInterfaceClass;
      index->ifaces_num++;
    }
    if (desc_type == USB_DT_ENDPOINT && index->ifaces_num > 0) {
      struct usb_iface_index* iface = &index->ifaces[index->ifaces_num - 1];
      if (iface->eps_num < USB_MAX_EP_NUM) {
        memcpy(&iface->eps[iface->eps_num].desc, buffer + offset,
               sizeof(iface->eps[iface->eps_num].desc));
        iface->eps_num++;
      }
    }
    offset += desc_length;
  }
  return true;
}

static struct usb_device_index* add_usb_index(int fd, const char* dev,
                                              size_t dev_len)
{
  int i = __atomic_fetch_add(&usb_devices_num, 1, __ATOMIC_RELAXED);
  if (i >= USB_MAX_FDS)
    return NULL;
  if (!parse_usb_descriptor(dev, dev_len, &usb_devices[i].index))
    return NULL;
  __atomic_store_n(&usb_devices[i].fd, fd, __ATOMIC_RELEASE);
  return &usb_devices[i].index;
}

struct vusb_connect_string_descriptor {
  uint32_t len;
  char* str;
} __attribute__((packed));

struct vusb_connect_descriptors {
  uint32_t qual_len;
  char* qual;
  uint32_t bos_len;
  char* bos;
  uint32_t strs_len;
  struct vusb_connect_string_descriptor strs[0];
} __attribute__((packed));

static const char default_string[] = {8, USB_DT_STRING, 's', 0, 'y', 0, 'z', 0};

static const char default_lang_id[] = {4, USB_DT_STRING, 0x09, 0x04};

static bool
lookup_connect_response_in(int fd, const struct vusb_connect_descriptors* descs,
                           const struct usb_ctrlrequest* ctrl,
                           struct usb_qualifier_descriptor* qual,
                           char** response_data, uint32_t* response_length)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  uint8_t str_idx;
  if (!index)
    return false;
  switch (ctrl->bRequestType & USB_TYPE_MASK) {
  case USB_TYPE_STANDARD:
    switch (ctrl->bRequest) {
    case USB_REQ_GET_DESCRIPTOR:
      switch (ctrl->wValue >> 8) {
      case USB_DT_DEVICE:
        *response_data = (char*)index->dev;
        *response_length = sizeof(*index->dev);
        return true;
      case USB_DT_CONFIG:
        *response_data = (char*)index->config;
        *response_length = index->config_length;
        return true;
      case USB_DT_STRING:
        str_idx = (uint8_t)ctrl->wValue;
        if (descs && str_idx < descs->strs_len) {
          *response_data = descs->strs[str_idx].str;
          *response_length = descs->strs[str_idx].len;
          return true;
        }
        if (str_idx == 0) {
          *response_data = (char*)&default_lang_id[0];
          *response_length = default_lang_id[0];
          return true;
        }
        *response_data = (char*)&default_string[0];
        *response_length = default_string[0];
        return true;
      case USB_DT_BOS:
        *response_data = descs->bos;
        *response_length = descs->bos_len;
        return true;
      case USB_DT_DEVICE_QUALIFIER:
        if (!descs->qual) {
          qual->bLength = sizeof(*qual);
          qual->bDescriptorType = USB_DT_DEVICE_QUALIFIER;
          qual->bcdUSB = index->dev->bcdUSB;
          qual->bDeviceClass = index->dev->bDeviceClass;
          qual->bDeviceSubClass = index->dev->bDeviceSubClass;
          qual->bDeviceProtocol = index->dev->bDeviceProtocol;
          qual->bMaxPacketSize0 = index->dev->bMaxPacketSize0;
          qual->bNumConfigurations = index->dev->bNumConfigurations;
          qual->bRESERVED = 0;
          *response_data = (char*)qual;
          *response_length = sizeof(*qual);
          return true;
        }
        *response_data = descs->qual;
        *response_length = descs->qual_len;
        return true;
      default:
        break;
      }
      break;
    default:
      break;
    }
    break;
  default:
    break;
  }
  return false;
}

typedef bool (*lookup_connect_out_response_t)(
    int fd, const struct vusb_connect_descriptors* descs,
    const struct usb_ctrlrequest* ctrl, bool* done);

static bool lookup_connect_response_out_generic(
    int fd, const struct vusb_connect_descriptors* descs,
    const struct usb_ctrlrequest* ctrl, bool* done)
{
  switch (ctrl->bRequestType & USB_TYPE_MASK) {
  case USB_TYPE_STANDARD:
    switch (ctrl->bRequest) {
    case USB_REQ_SET_CONFIGURATION:
      *done = true;
      return true;
    default:
      break;
    }
    break;
  }
  return false;
}

struct vusb_descriptor {
  uint8_t req_type;
  uint8_t desc_type;
  uint32_t len;
  char data[0];
} __attribute__((packed));

struct vusb_descriptors {
  uint32_t len;
  struct vusb_descriptor* generic;
  struct vusb_descriptor* descs[0];
} __attribute__((packed));

struct vusb_response {
  uint8_t type;
  uint8_t req;
  uint32_t len;
  char data[0];
} __attribute__((packed));

struct vusb_responses {
  uint32_t len;
  struct vusb_response* generic;
  struct vusb_response* resps[0];
} __attribute__((packed));

static bool lookup_control_response(const struct vusb_descriptors* descs,
                                    const struct vusb_responses* resps,
                                    struct usb_ctrlrequest* ctrl,
                                    char** response_data,
                                    uint32_t* response_length)
{
  int descs_num = 0;
  int resps_num = 0;
  if (descs)
    descs_num = (descs->len - offsetof(struct vusb_descriptors, descs)) /
                sizeof(descs->descs[0]);
  if (resps)
    resps_num = (resps->len - offsetof(struct vusb_responses, resps)) /
                sizeof(resps->resps[0]);
  uint8_t req = ctrl->bRequest;
  uint8_t req_type = ctrl->bRequestType & USB_TYPE_MASK;
  uint8_t desc_type = ctrl->wValue >> 8;
  if (req == USB_REQ_GET_DESCRIPTOR) {
    int i;
    for (i = 0; i < descs_num; i++) {
      struct vusb_descriptor* desc = descs->descs[i];
      if (!desc)
        continue;
      if (desc->req_type == req_type && desc->desc_type == desc_type) {
        *response_length = desc->len;
        if (*response_length != 0)
          *response_data = &desc->data[0];
        else
          *response_data = NULL;
        return true;
      }
    }
    if (descs && descs->generic) {
      *response_data = &descs->generic->data[0];
      *response_length = descs->generic->len;
      return true;
    }
  } else {
    int i;
    for (i = 0; i < resps_num; i++) {
      struct vusb_response* resp = resps->resps[i];
      if (!resp)
        continue;
      if (resp->type == req_type && resp->req == req) {
        *response_length = resp->len;
        if (*response_length != 0)
          *response_data = &resp->data[0];
        else
          *response_data = NULL;
        return true;
      }
    }
    if (resps && resps->generic) {
      *response_data = &resps->generic->data[0];
      *response_length = resps->generic->len;
      return true;
    }
  }
  return false;
}

#define UDC_NAME_LENGTH_MAX 128

struct usb_raw_init {
  __u8 driver_name[UDC_NAME_LENGTH_MAX];
  __u8 device_name[UDC_NAME_LENGTH_MAX];
  __u8 speed;
};

enum usb_raw_event_type {
  USB_RAW_EVENT_INVALID = 0,
  USB_RAW_EVENT_CONNECT = 1,
  USB_RAW_EVENT_CONTROL = 2,
};

struct usb_raw_event {
  __u32 type;
  __u32 length;
  __u8 data[0];
};

struct usb_raw_ep_io {
  __u16 ep;
  __u16 flags;
  __u32 length;
  __u8 data[0];
};

#define USB_RAW_EPS_NUM_MAX 30
#define USB_RAW_EP_NAME_MAX 16
#define USB_RAW_EP_ADDR_ANY 0xff

struct usb_raw_ep_caps {
  __u32 type_control : 1;
  __u32 type_iso : 1;
  __u32 type_bulk : 1;
  __u32 type_int : 1;
  __u32 dir_in : 1;
  __u32 dir_out : 1;
};

struct usb_raw_ep_limits {
  __u16 maxpacket_limit;
  __u16 max_streams;
  __u32 reserved;
};

struct usb_raw_ep_info {
  __u8 name[USB_RAW_EP_NAME_MAX];
  __u32 addr;
  struct usb_raw_ep_caps caps;
  struct usb_raw_ep_limits limits;
};

struct usb_raw_eps_info {
  struct usb_raw_ep_info eps[USB_RAW_EPS_NUM_MAX];
};

#define USB_RAW_IOCTL_INIT _IOW('U', 0, struct usb_raw_init)
#define USB_RAW_IOCTL_RUN _IO('U', 1)
#define USB_RAW_IOCTL_EVENT_FETCH _IOR('U', 2, struct usb_raw_event)
#define USB_RAW_IOCTL_EP0_WRITE _IOW('U', 3, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP0_READ _IOWR('U', 4, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP_ENABLE _IOW('U', 5, struct usb_endpoint_descriptor)
#define USB_RAW_IOCTL_EP_DISABLE _IOW('U', 6, __u32)
#define USB_RAW_IOCTL_EP_WRITE _IOW('U', 7, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_EP_READ _IOWR('U', 8, struct usb_raw_ep_io)
#define USB_RAW_IOCTL_CONFIGURE _IO('U', 9)
#define USB_RAW_IOCTL_VBUS_DRAW _IOW('U', 10, __u32)
#define USB_RAW_IOCTL_EPS_INFO _IOR('U', 11, struct usb_raw_eps_info)
#define USB_RAW_IOCTL_EP0_STALL _IO('U', 12)
#define USB_RAW_IOCTL_EP_SET_HALT _IOW('U', 13, __u32)
#define USB_RAW_IOCTL_EP_CLEAR_HALT _IOW('U', 14, __u32)
#define USB_RAW_IOCTL_EP_SET_WEDGE _IOW('U', 15, __u32)

static int usb_raw_open()
{
  return open("/dev/raw-gadget", O_RDWR);
}

static int usb_raw_init(int fd, uint32_t speed, const char* driver,
                        const char* device)
{
  struct usb_raw_init arg;
  strncpy((char*)&arg.driver_name[0], driver, sizeof(arg.driver_name));
  strncpy((char*)&arg.device_name[0], device, sizeof(arg.device_name));
  arg.speed = speed;
  return ioctl(fd, USB_RAW_IOCTL_INIT, &arg);
}

static int usb_raw_run(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_RUN, 0);
}

static int usb_raw_configure(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_CONFIGURE, 0);
}

static int usb_raw_vbus_draw(int fd, uint32_t power)
{
  return ioctl(fd, USB_RAW_IOCTL_VBUS_DRAW, power);
}

static int usb_raw_ep0_write(int fd, struct usb_raw_ep_io* io)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_WRITE, io);
}

static int usb_raw_ep0_read(int fd, struct usb_raw_ep_io* io)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_READ, io);
}

static int usb_raw_event_fetch(int fd, struct usb_raw_event* event)
{
  return ioctl(fd, USB_RAW_IOCTL_EVENT_FETCH, event);
}

static int usb_raw_ep_enable(int fd, struct usb_endpoint_descriptor* desc)
{
  return ioctl(fd, USB_RAW_IOCTL_EP_ENABLE, desc);
}

static int usb_raw_ep_disable(int fd, int ep)
{
  return ioctl(fd, USB_RAW_IOCTL_EP_DISABLE, ep);
}

static int usb_raw_ep0_stall(int fd)
{
  return ioctl(fd, USB_RAW_IOCTL_EP0_STALL, 0);
}

static int lookup_interface(int fd, uint8_t bInterfaceNumber,
                            uint8_t bAlternateSetting)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  if (!index)
    return -1;
  for (int i = 0; i < index->ifaces_num; i++) {
    if (index->ifaces[i].bInterfaceNumber == bInterfaceNumber &&
        index->ifaces[i].bAlternateSetting == bAlternateSetting)
      return i;
  }
  return -1;
}

#define USB_MAX_PACKET_SIZE 4096

struct usb_raw_control_event {
  struct usb_raw_event inner;
  struct usb_ctrlrequest ctrl;
  char data[USB_MAX_PACKET_SIZE];
};

struct usb_raw_ep_io_data {
  struct usb_raw_ep_io inner;
  char data[USB_MAX_PACKET_SIZE];
};

static void set_interface(int fd, int n)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  if (!index)
    return;
  if (index->iface_cur >= 0 && index->iface_cur < index->ifaces_num) {
    for (int ep = 0; ep < index->ifaces[index->iface_cur].eps_num; ep++) {
      int rv = usb_raw_ep_disable(
          fd, index->ifaces[index->iface_cur].eps[ep].handle);
      if (rv < 0) {
      } else {
      }
    }
  }
  if (n >= 0 && n < index->ifaces_num) {
    for (int ep = 0; ep < index->ifaces[n].eps_num; ep++) {
      int rv = usb_raw_ep_enable(fd, &index->ifaces[n].eps[ep].desc);
      if (rv < 0) {
      } else {
        index->ifaces[n].eps[ep].handle = rv;
      }
    }
    index->iface_cur = n;
  }
}

static int configure_device(int fd)
{
  struct usb_device_index* index = lookup_usb_index(fd);
  if (!index)
    return -1;
  int rv = usb_raw_vbus_draw(fd, index->bMaxPower);
  if (rv < 0) {
    return rv;
  }
  rv = usb_raw_configure(fd);
  if (rv < 0) {
    return rv;
  }
  set_interface(fd, 0);
  return 0;
}

static volatile long
syz_usb_connect_impl(uint64_t speed, uint64_t dev_len, const char* dev,
                     const struct vusb_connect_descriptors* descs,
                     lookup_connect_out_response_t lookup_connect_response_out)
{
  if (!dev) {
    return -1;
  }
  int fd = usb_raw_open();
  if (fd < 0) {
    return fd;
  }
  if (fd >= MAX_FDS) {
    close(fd);
    return -1;
  }
  struct usb_device_index* index = add_usb_index(fd, dev, dev_len);
  if (!index) {
    return -1;
  }
  char device[32];
  sprintf(&device[0], "dummy_udc.%llu", procid);
  int rv = usb_raw_init(fd, speed, "dummy_udc", &device[0]);
  if (rv < 0) {
    return rv;
  }
  rv = usb_raw_run(fd);
  if (rv < 0) {
    return rv;
  }
  bool done = false;
  while (!done) {
    struct usb_raw_control_event event;
    event.inner.type = 0;
    event.inner.length = sizeof(event.ctrl);
    rv = usb_raw_event_fetch(fd, (struct usb_raw_event*)&event);
    if (rv < 0) {
      return rv;
    }
    if (event.inner.type != USB_RAW_EVENT_CONTROL)
      continue;
    char* response_data = NULL;
    uint32_t response_length = 0;
    struct usb_qualifier_descriptor qual;
    if (event.ctrl.bRequestType & USB_DIR_IN) {
      if (!lookup_connect_response_in(fd, descs, &event.ctrl, &qual,
                                      &response_data, &response_length)) {
        usb_raw_ep0_stall(fd);
        continue;
      }
    } else {
      if (!lookup_connect_response_out(fd, descs, &event.ctrl, &done)) {
        usb_raw_ep0_stall(fd);
        continue;
      }
      response_data = NULL;
      response_length = event.ctrl.wLength;
    }
    if ((event.ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD &&
        event.ctrl.bRequest == USB_REQ_SET_CONFIGURATION) {
      rv = configure_device(fd);
      if (rv < 0) {
        return rv;
      }
    }
    struct usb_raw_ep_io_data response;
    response.inner.ep = 0;
    response.inner.flags = 0;
    if (response_length > sizeof(response.data))
      response_length = 0;
    if (event.ctrl.wLength < response_length)
      response_length = event.ctrl.wLength;
    response.inner.length = response_length;
    if (response_data)
      memcpy(&response.data[0], response_data, response_length);
    else
      memset(&response.data[0], 0, response_length);
    if (event.ctrl.bRequestType & USB_DIR_IN) {
      rv = usb_raw_ep0_write(fd, (struct usb_raw_ep_io*)&response);
    } else {
      rv = usb_raw_ep0_read(fd, (struct usb_raw_ep_io*)&response);
    }
    if (rv < 0) {
      return rv;
    }
  }
  sleep_ms(200);
  return fd;
}

static volatile long syz_usb_connect(volatile long a0, volatile long a1,
                                     volatile long a2, volatile long a3)
{
  uint64_t speed = a0;
  uint64_t dev_len = a1;
  const char* dev = (const char*)a2;
  const struct vusb_connect_descriptors* descs =
      (const struct vusb_connect_descriptors*)a3;
  return syz_usb_connect_impl(speed, dev_len, dev, descs,
                              &lookup_connect_response_out_generic);
}

static volatile long syz_usb_control_io(volatile long a0, volatile long a1,
                                        volatile long a2)
{
  int fd = a0;
  const struct vusb_descriptors* descs = (const struct vusb_descriptors*)a1;
  const struct vusb_responses* resps = (const struct vusb_responses*)a2;
  struct usb_raw_control_event event;
  event.inner.type = 0;
  event.inner.length = USB_MAX_PACKET_SIZE;
  int rv = usb_raw_event_fetch(fd, (struct usb_raw_event*)&event);
  if (rv < 0) {
    return rv;
  }
  if (event.inner.type != USB_RAW_EVENT_CONTROL) {
    return -1;
  }
  char* response_data = NULL;
  uint32_t response_length = 0;
  if ((event.ctrl.bRequestType & USB_DIR_IN) && event.ctrl.wLength) {
    if (!lookup_control_response(descs, resps, &event.ctrl, &response_data,
                                 &response_length)) {
      usb_raw_ep0_stall(fd);
      return -1;
    }
  } else {
    if ((event.ctrl.bRequestType & USB_TYPE_MASK) == USB_TYPE_STANDARD ||
        event.ctrl.bRequest == USB_REQ_SET_INTERFACE) {
      int iface_num = event.ctrl.wIndex;
      int alt_set = event.ctrl.wValue;
      int iface_index = lookup_interface(fd, iface_num, alt_set);
      if (iface_index < 0) {
      } else {
        set_interface(fd, iface_index);
      }
    }
    response_length = event.ctrl.wLength;
  }
  struct usb_raw_ep_io_data response;
  response.inner.ep = 0;
  response.inner.flags = 0;
  if (response_length > sizeof(response.data))
    response_length = 0;
  if (event.ctrl.wLength < response_length)
    response_length = event.ctrl.wLength;
  if ((event.ctrl.bRequestType & USB_DIR_IN) && !event.ctrl.wLength) {
    response_length = USB_MAX_PACKET_SIZE;
  }
  response.inner.length = response_length;
  if (response_data)
    memcpy(&response.data[0], response_data, response_length);
  else
    memset(&response.data[0], 0, response_length);
  if ((event.ctrl.bRequestType & USB_DIR_IN) && event.ctrl.wLength) {
    rv = usb_raw_ep0_write(fd, (struct usb_raw_ep_io*)&response);
  } else {
    rv = usb_raw_ep0_read(fd, (struct usb_raw_ep_io*)&response);
  }
  if (rv < 0) {
    return rv;
  }
  sleep_ms(200);
  return 0;
}

static long syz_genetlink_get_family_id(volatile long name,
                                        volatile long sock_arg)
{
  int fd = sock_arg;
  if (fd < 0) {
    fd = socket(AF_NETLINK, SOCK_RAW, NETLINK_GENERIC);
    if (fd == -1) {
      return -1;
    }
  }
  struct nlmsg nlmsg_tmp;
  int ret = netlink_query_family_id(&nlmsg_tmp, fd, (char*)name, false);
  if ((int)sock_arg < 0)
    close(fd);
  if (ret < 0) {
    return -1;
  }
  return ret;
}

#define FS_IOC_SETFLAGS _IOW('f', 2, long)
static void remove_dir(const char* dir)
{
  int iter = 0;
  DIR* dp = 0;
  const int umount_flags = MNT_FORCE | UMOUNT_NOFOLLOW;

retry:
  while (umount2(dir, umount_flags) == 0) {
  }
  dp = opendir(dir);
  if (dp == NULL) {
    if (errno == EMFILE) {
      exit(1);
    }
    exit(1);
  }
  struct dirent* ep = 0;
  while ((ep = readdir(dp))) {
    if (strcmp(ep->d_name, ".") == 0 || strcmp(ep->d_name, "..") == 0)
      continue;
    char filename[FILENAME_MAX];
    snprintf(filename, sizeof(filename), "%s/%s", dir, ep->d_name);
    while (umount2(filename, umount_flags) == 0) {
    }
    struct stat st;
    if (lstat(filename, &st))
      exit(1);
    if (S_ISDIR(st.st_mode)) {
      remove_dir(filename);
      continue;
    }
    int i;
    for (i = 0;; i++) {
      if (unlink(filename) == 0)
        break;
      if (errno == EPERM) {
        int fd = open(filename, O_RDONLY);
        if (fd != -1) {
          long flags = 0;
          if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0) {
          }
          close(fd);
          continue;
        }
      }
      if (errno == EROFS) {
        break;
      }
      if (errno != EBUSY || i > 100)
        exit(1);
      if (umount2(filename, umount_flags))
        exit(1);
    }
  }
  closedir(dp);
  for (int i = 0;; i++) {
    if (rmdir(dir) == 0)
      break;
    if (i < 100) {
      if (errno == EPERM) {
        int fd = open(dir, O_RDONLY);
        if (fd != -1) {
          long flags = 0;
          if (ioctl(fd, FS_IOC_SETFLAGS, &flags) == 0) {
          }
          close(fd);
          continue;
        }
      }
      if (errno == EROFS) {
        break;
      }
      if (errno == EBUSY) {
        if (umount2(dir, umount_flags))
          exit(1);
        continue;
      }
      if (errno == ENOTEMPTY) {
        if (iter < 100) {
          iter++;
          goto retry;
        }
      }
    }
    exit(1);
  }
}

static void kill_and_wait(int pid, int* status)
{
  kill(-pid, SIGKILL);
  kill(pid, SIGKILL);
  for (int i = 0; i < 100; i++) {
    if (waitpid(-1, status, WNOHANG | __WALL) == pid)
      return;
    usleep(1000);
  }
  DIR* dir = opendir("/sys/fs/fuse/connections");
  if (dir) {
    for (;;) {
      struct dirent* ent = readdir(dir);
      if (!ent)
        break;
      if (strcmp(ent->d_name, ".") == 0 || strcmp(ent->d_name, "..") == 0)
        continue;
      char abort[300];
      snprintf(abort, sizeof(abort), "/sys/fs/fuse/connections/%s/abort",
               ent->d_name);
      int fd = open(abort, O_WRONLY);
      if (fd == -1) {
        continue;
      }
      if (write(fd, abort, 1) < 0) {
      }
      close(fd);
    }
    closedir(dir);
  } else {
  }
  while (waitpid(-1, status, __WALL) != pid) {
  }
}

static void setup_test()
{
  prctl(PR_SET_PDEATHSIG, SIGKILL, 0, 0, 0);
  setpgrp();
  write_file("/proc/self/oom_score_adj", "1000");
  if (symlink("/dev/binderfs", "./binderfs")) {
  }
}

static void setup_sysctl()
{
  int cad_pid = fork();
  if (cad_pid < 0)
    exit(1);
  if (cad_pid == 0) {
    for (;;)
      sleep(100);
  }
  char tmppid[32];
  snprintf(tmppid, sizeof(tmppid), "%d", cad_pid);
  struct {
    const char* name;
    const char* data;
  } files[] = {
      {"/sys/kernel/debug/x86/nmi_longest_ns", "10000000000"},
      {"/proc/sys/kernel/hung_task_check_interval_secs", "20"},
      {"/proc/sys/net/core/bpf_jit_kallsyms", "1"},
      {"/proc/sys/net/core/bpf_jit_harden", "0"},
      {"/proc/sys/kernel/kptr_restrict", "0"},
      {"/proc/sys/kernel/softlockup_all_cpu_backtrace", "1"},
      {"/proc/sys/fs/mount-max", "100"},
      {"/proc/sys/vm/oom_dump_tasks", "0"},
      {"/proc/sys/debug/exception-trace", "0"},
      {"/proc/sys/kernel/printk", "7 4 1 3"},
      {"/proc/sys/kernel/keys/gc_delay", "1"},
      {"/proc/sys/vm/oom_kill_allocating_task", "1"},
      {"/proc/sys/kernel/ctrl-alt-del", "0"},
      {"/proc/sys/kernel/cad_pid", tmppid},
  };
  for (size_t i = 0; i < sizeof(files) / sizeof(files[0]); i++) {
    if (!write_file(files[i].name, files[i].data)) {
    }
  }
  kill(cad_pid, SIGKILL);
  while (waitpid(cad_pid, NULL, 0) != cad_pid)
    ;
}

struct thread_t {
  int created, call;
  event_t ready, done;
};

static struct thread_t threads[16];
static void execute_call(int call);
static int running;

static void* thr(void* arg)
{
  struct thread_t* th = (struct thread_t*)arg;
  for (;;) {
    event_wait(&th->ready);
    event_reset(&th->ready);
    execute_call(th->call);
    __atomic_fetch_sub(&running, 1, __ATOMIC_RELAXED);
    event_set(&th->done);
  }
  return 0;
}

static void execute_one(void)
{
  if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
  }
  int i, call, thread;
  for (call = 0; call < 17; call++) {
    for (thread = 0; thread < (int)(sizeof(threads) / sizeof(threads[0]));
         thread++) {
      struct thread_t* th = &threads[thread];
      if (!th->created) {
        th->created = 1;
        event_init(&th->ready);
        event_init(&th->done);
        event_set(&th->done);
        thread_start(thr, th);
      }
      if (!event_isset(&th->done))
        continue;
      event_reset(&th->done);
      th->call = call;
      __atomic_fetch_add(&running, 1, __ATOMIC_RELAXED);
      event_set(&th->ready);
      event_timedwait(&th->done,
                      50 + (call == 1 ? 3000 : 0) + (call == 2 ? 300 : 0) +
                          (call == 3 ? 300 : 0) + (call == 4 ? 300 : 0) +
                          (call == 5 ? 300 : 0) + (call == 6 ? 300 : 0) +
                          (call == 7 ? 300 : 0) + (call == 8 ? 300 : 0) +
                          (call == 9 ? 300 : 0) + (call == 10 ? 300 : 0) +
                          (call == 11 ? 300 : 0) + (call == 12 ? 300 : 0));
      break;
    }
  }
  for (i = 0; i < 100 && __atomic_load_n(&running, __ATOMIC_RELAXED); i++)
    sleep_ms(1);
}

static void execute_one(void);

#define WAIT_FLAGS __WALL

static void loop(void)
{
  int iter = 0;
  for (;; iter++) {
    char cwdbuf[32];
    sprintf(cwdbuf, "./%d", iter);
    if (mkdir(cwdbuf, 0777))
      exit(1);
    int pid = fork();
    if (pid < 0)
      exit(1);
    if (pid == 0) {
      if (chdir(cwdbuf))
        exit(1);
      setup_test();
      execute_one();
      exit(0);
    }
    int status = 0;
    uint64_t start = current_time_ms();
    for (;;) {
      sleep_ms(10);
      if (waitpid(-1, &status, WNOHANG | WAIT_FLAGS) == pid)
        break;
      if (current_time_ms() - start < 5000)
        continue;
      kill_and_wait(pid, &status);
      break;
    }
    remove_dir(cwdbuf);
  }
}

uint64_t r[2] = {0xffffffffffffffff, 0xffffffffffffffff};

void execute_call(int call)
{
  intptr_t res = 0;
  switch (call) {
  case 0:
    //  openat$rnullb arguments: [
    //    fd: const = 0xffffffffffffff9c (8 bytes)
    //    file: nil
    //    flags: open_flags = 0x60a00 (4 bytes)
    //    mode: const = 0x0 (2 bytes)
    //  ]
    //  returns fd_block
    syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul, /*file=*/0ul,
            /*flags=O_TRUNC|O_NONBLOCK|O_NOFOLLOW|O_NOATIME*/ 0x60a00,
            /*mode=*/0);
    break;
  case 1:
    //  syz_usb_connect$rtl8150 arguments: [
    //    speed: usb_device_speed = 0x3 (8 bytes)
    //    dev_len: len = 0x3f (8 bytes)
    //    dev: ptr[in, usb_device_descriptor_rtl8150] {
    //      usb_device_descriptor_rtl8150 {
    //        inner: usb_device_descriptor_verbose_t[const[0x200, int16],
    //        USB_CLASS_VENDOR_SPEC, USB_SUBCLASS_VENDOR_SPEC, 0xff, const[64,
    //        int8], 0xbda, 0x8150, 0, array[usb_config_descriptor_rtl8150, 1]]
    //        {
    //          bLength: const = 0x12 (1 bytes)
    //          bDescriptorType: const = 0x1 (1 bytes)
    //          bcdUSB: const = 0x200 (2 bytes)
    //          bDeviceClass: const = 0xff (1 bytes)
    //          bDeviceSubClass: const = 0xff (1 bytes)
    //          bDeviceProtocol: const = 0xff (1 bytes)
    //          bMaxPacketSize0: const = 0x40 (1 bytes)
    //          idVendor: const = 0xbda (2 bytes)
    //          idProduct: const = 0x8150 (2 bytes)
    //          bcdDevice: const = 0x0 (2 bytes)
    //          iManufacturer: const = 0x1 (1 bytes)
    //          iProduct: const = 0x2 (1 bytes)
    //          iSerialNumber: const = 0x3 (1 bytes)
    //          bNumConfigurations: len = 0x1 (1 bytes)
    //          configs: array[usb_config_descriptor_rtl8150] {
    //            usb_config_descriptor_rtl8150 {
    //              inner: usb_config_descriptor_verbose_t[const[1, int8],
    //              const[1, int8], const[0, int8], const[USB_CONFIG_ATT_ONE,
    //              int8], const[250, int8], usb_interface_descriptor_rtl8150] {
    //                bLength: const = 0x9 (1 bytes)
    //                bDescriptorType: const = 0x2 (1 bytes)
    //                wTotalLength: len = 0x2d (2 bytes)
    //                bNumInterfaces: const = 0x1 (1 bytes)
    //                bConfigurationValue: const = 0x1 (1 bytes)
    //                iConfiguration: const = 0x0 (1 bytes)
    //                bmAttributes: const = 0x80 (1 bytes)
    //                bMaxPower: const = 0xfa (1 bytes)
    //                interfaces: usb_interface_descriptor_rtl8150 {
    //                  iface: usb_interface_descriptor_verbose_t[const[0,
    //                  int8], const[0, int8], const[3, int8],
    //                  const[USB_CLASS_VENDOR_SPEC, int8], const[0, int8],
    //                  const[0, int8], const[0, int8], void,
    //                  usb_endpoint_descriptors_rtl8150] {
    //                    bLength: const = 0x9 (1 bytes)
    //                    bDescriptorType: const = 0x4 (1 bytes)
    //                    bInterfaceNumber: const = 0x0 (1 bytes)
    //                    bAlternateSetting: const = 0x0 (1 bytes)
    //                    bNumEndpoints: const = 0x3 (1 bytes)
    //                    bInterfaceClass: const = 0xff (1 bytes)
    //                    bInterfaceSubClass: const = 0x0 (1 bytes)
    //                    bInterfaceProtocol: const = 0x0 (1 bytes)
    //                    iInterface: const = 0x0 (1 bytes)
    //                    extra: buffer: {} (length 0x0)
    //                    endpoints: usb_endpoint_descriptors_rtl8150 {
    //                      bulk_in:
    //                      usb_endpoint_descriptor_verbose_t[const[USB_FIXED_ENDPOINT_BULK_IN_ADDR,
    //                      int8], const[USB_ENDPOINT_BULK_ATTR, int8],
    //                      const[512, int16], const[0, int8], const[0, int8],
    //                      const[0, int8], void] {
    //                        bLength: const = 0x9 (1 bytes)
    //                        bDescriptorType: const = 0x5 (1 bytes)
    //                        bEndpointAddress: const = 0x81 (1 bytes)
    //                        bmAttributes: const = 0x2 (1 bytes)
    //                        wMaxPacketSize: const = 0x200 (2 bytes)
    //                        bInterval: const = 0x0 (1 bytes)
    //                        bRefresh: const = 0x0 (1 bytes)
    //                        bSynchAddress: const = 0x0 (1 bytes)
    //                        extra: buffer: {} (length 0x0)
    //                      }
    //                      bulk_out:
    //                      usb_endpoint_descriptor_verbose_t[const[USB_FIXED_ENDPOINT_BULK_OUT_ADDR,
    //                      int8], const[USB_ENDPOINT_BULK_ATTR, int8],
    //                      const[512, int16], const[0, int8], const[0, int8],
    //                      const[0, int8], void] {
    //                        bLength: const = 0x9 (1 bytes)
    //                        bDescriptorType: const = 0x5 (1 bytes)
    //                        bEndpointAddress: const = 0x2 (1 bytes)
    //                        bmAttributes: const = 0x2 (1 bytes)
    //                        wMaxPacketSize: const = 0x200 (2 bytes)
    //                        bInterval: const = 0x0 (1 bytes)
    //                        bRefresh: const = 0x0 (1 bytes)
    //                        bSynchAddress: const = 0x0 (1 bytes)
    //                        extra: buffer: {} (length 0x0)
    //                      }
    //                      int_in:
    //                      usb_endpoint_descriptor_verbose_t[const[USB_FIXED_ENDPOINT_INT_IN_ADDR,
    //                      int8], const[USB_ENDPOINT_INT_ATTR, int8], const[64,
    //                      int16], const[1, int8], const[0, int8], const[0,
    //                      int8], void] {
    //                        bLength: const = 0x9 (1 bytes)
    //                        bDescriptorType: const = 0x5 (1 bytes)
    //                        bEndpointAddress: const = 0x83 (1 bytes)
    //                        bmAttributes: const = 0x3 (1 bytes)
    //                        wMaxPacketSize: const = 0x40 (2 bytes)
    //                        bInterval: const = 0x1 (1 bytes)
    //                        bRefresh: const = 0x0 (1 bytes)
    //                        bSynchAddress: const = 0x0 (1 bytes)
    //                        extra: buffer: {} (length 0x0)
    //                      }
    //                    }
    //                  }
    //                }
    //              }
    //            }
    //          }
    //        }
    //      }
    //    }
    //    conn_descs: const = 0x0 (8 bytes)
    //  ]
    //  returns fd_usb_rtl8150
    NONFAILING(*(uint8_t*)0x200000000000 = 0x12);
    NONFAILING(*(uint8_t*)0x200000000001 = 1);
    NONFAILING(*(uint16_t*)0x200000000002 = 0x200);
    NONFAILING(*(uint8_t*)0x200000000004 = -1);
    NONFAILING(*(uint8_t*)0x200000000005 = -1);
    NONFAILING(*(uint8_t*)0x200000000006 = -1);
    NONFAILING(*(uint8_t*)0x200000000007 = 0x40);
    NONFAILING(*(uint16_t*)0x200000000008 = 0xbda);
    NONFAILING(*(uint16_t*)0x20000000000a = 0x8150);
    NONFAILING(*(uint16_t*)0x20000000000c = 0);
    NONFAILING(*(uint8_t*)0x20000000000e = 1);
    NONFAILING(*(uint8_t*)0x20000000000f = 2);
    NONFAILING(*(uint8_t*)0x200000000010 = 3);
    NONFAILING(*(uint8_t*)0x200000000011 = 1);
    NONFAILING(*(uint8_t*)0x200000000012 = 9);
    NONFAILING(*(uint8_t*)0x200000000013 = 2);
    NONFAILING(*(uint16_t*)0x200000000014 = 0x2d);
    NONFAILING(*(uint8_t*)0x200000000016 = 1);
    NONFAILING(*(uint8_t*)0x200000000017 = 1);
    NONFAILING(*(uint8_t*)0x200000000018 = 0);
    NONFAILING(*(uint8_t*)0x200000000019 = 0x80);
    NONFAILING(*(uint8_t*)0x20000000001a = 0xfa);
    NONFAILING(*(uint8_t*)0x20000000001b = 9);
    NONFAILING(*(uint8_t*)0x20000000001c = 4);
    NONFAILING(*(uint8_t*)0x20000000001d = 0);
    NONFAILING(*(uint8_t*)0x20000000001e = 0);
    NONFAILING(*(uint8_t*)0x20000000001f = 3);
    NONFAILING(*(uint8_t*)0x200000000020 = -1);
    NONFAILING(*(uint8_t*)0x200000000021 = 0);
    NONFAILING(*(uint8_t*)0x200000000022 = 0);
    NONFAILING(*(uint8_t*)0x200000000023 = 0);
    NONFAILING(*(uint8_t*)0x200000000024 = 9);
    NONFAILING(*(uint8_t*)0x200000000025 = 5);
    NONFAILING(*(uint8_t*)0x200000000026 = 0x81);
    NONFAILING(*(uint8_t*)0x200000000027 = 2);
    NONFAILING(*(uint16_t*)0x200000000028 = 0x200);
    NONFAILING(*(uint8_t*)0x20000000002a = 0);
    NONFAILING(*(uint8_t*)0x20000000002b = 0);
    NONFAILING(*(uint8_t*)0x20000000002c = 0);
    NONFAILING(*(uint8_t*)0x20000000002d = 9);
    NONFAILING(*(uint8_t*)0x20000000002e = 5);
    NONFAILING(*(uint8_t*)0x20000000002f = 2);
    NONFAILING(*(uint8_t*)0x200000000030 = 2);
    NONFAILING(*(uint16_t*)0x200000000031 = 0x200);
    NONFAILING(*(uint8_t*)0x200000000033 = 0);
    NONFAILING(*(uint8_t*)0x200000000034 = 0);
    NONFAILING(*(uint8_t*)0x200000000035 = 0);
    NONFAILING(*(uint8_t*)0x200000000036 = 9);
    NONFAILING(*(uint8_t*)0x200000000037 = 5);
    NONFAILING(*(uint8_t*)0x200000000038 = 0x83);
    NONFAILING(*(uint8_t*)0x200000000039 = 3);
    NONFAILING(*(uint16_t*)0x20000000003a = 0x40);
    NONFAILING(*(uint8_t*)0x20000000003c = 1);
    NONFAILING(*(uint8_t*)0x20000000003d = 0);
    NONFAILING(*(uint8_t*)0x20000000003e = 0);
    res = -1;
    NONFAILING(res =
                   syz_usb_connect(/*speed=USB_SPEED_HIGH*/ 3, /*dev_len=*/0x3f,
                                   /*dev=*/0x200000000000, /*conn_descs=*/0));
    if (res != -1)
      r[0] = res;
    break;
  case 2:
    //  syz_usb_control_io$rtl8150 arguments: [
    //    fd: fd_usb_rtl8150 (resource)
    //    descs: nil
    //    resps: nil
    //  ]
    NONFAILING(syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0));
    break;
  case 3:
    //  syz_usb_control_io$rtl8150 arguments: [
    //    fd: fd_usb_rtl8150 (resource)
    //    descs: nil
    //    resps: ptr[in, vusb_responses_rtl8150] {
    //      vusb_responses_rtl8150 {
    //        len: len = 0x2c (4 bytes)
    //        generic: nil
    //        USB_REQ_GET_INTERFACE: nil
    //        USB_REQ_GET_CONFIGURATION: nil
    //        RTL8150_REQ_GET_REGS: nil
    //        RTL8150_REQ_SET_REGS: ptr[in, vusb_response_t[RTL8150_REQT_WRITE,
    //        RTL8150_REQ_SET_REGS, array[int8, 0:6]]] {
    //          vusb_response_t[RTL8150_REQT_WRITE, RTL8150_REQ_SET_REGS,
    //          array[int8, 0:6]] {
    //            type: const = 0x40 (1 bytes)
    //            req: const = 0x5 (1 bytes)
    //            len: bytesize = 0x1 (4 bytes)
    //            data: buffer: {88} (length 0x1)
    //          }
    //        }
    //      }
    //    }
    //  ]
    NONFAILING(*(uint32_t*)0x2000000005c0 = 0x2c);
    NONFAILING(*(uint64_t*)0x2000000005c4 = 0);
    NONFAILING(*(uint64_t*)0x2000000005cc = 0);
    NONFAILING(*(uint64_t*)0x2000000005d4 = 0);
    NONFAILING(*(uint64_t*)0x2000000005dc = 0);
    NONFAILING(*(uint64_t*)0x2000000005e4 = 0x200000000580);
    NONFAILING(*(uint8_t*)0x200000000580 = 0x40);
    NONFAILING(*(uint8_t*)0x200000000581 = 5);
    NONFAILING(*(uint32_t*)0x200000000582 = 1);
    NONFAILING(memset((void*)0x200000000586, 136, 1));
    NONFAILING(
        syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0x2000000005c0));
    break;
  case 4:
    //  syz_usb_control_io$rtl8150 arguments: [
    //    fd: fd_usb_rtl8150 (resource)
    //    descs: nil
    //    resps: nil
    //  ]
    NONFAILING(syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0));
    break;
  case 5:
    //  syz_usb_control_io$rtl8150 arguments: [
    //    fd: fd_usb_rtl8150 (resource)
    //    descs: nil
    //    resps: nil
    //  ]
    NONFAILING(syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0));
    break;
  case 6:
    //  syz_usb_control_io arguments: [
    //    fd: fd_usb (resource)
    //    descs: nil
    //    resps: nil
    //  ]
    NONFAILING(syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0));
    break;
  case 7:
    //  syz_usb_control_io$rtl8150 arguments: [
    //    fd: fd_usb_rtl8150 (resource)
    //    descs: nil
    //    resps: ptr[in, vusb_responses_rtl8150] {
    //      vusb_responses_rtl8150 {
    //        len: len = 0x2c (4 bytes)
    //        generic: nil
    //        USB_REQ_GET_INTERFACE: nil
    //        USB_REQ_GET_CONFIGURATION: nil
    //        RTL8150_REQ_GET_REGS: nil
    //        RTL8150_REQ_SET_REGS: ptr[in, vusb_response_t[RTL8150_REQT_WRITE,
    //        RTL8150_REQ_SET_REGS, array[int8, 0:6]]] {
    //          vusb_response_t[RTL8150_REQT_WRITE, RTL8150_REQ_SET_REGS,
    //          array[int8, 0:6]] {
    //            type: const = 0x40 (1 bytes)
    //            req: const = 0x5 (1 bytes)
    //            len: bytesize = 0x1 (4 bytes)
    //            data: buffer: {a3} (length 0x1)
    //          }
    //        }
    //      }
    //    }
    //  ]
    NONFAILING(*(uint32_t*)0x200000001880 = 0x2c);
    NONFAILING(*(uint64_t*)0x200000001884 = 0);
    NONFAILING(*(uint64_t*)0x20000000188c = 0);
    NONFAILING(*(uint64_t*)0x200000001894 = 0);
    NONFAILING(*(uint64_t*)0x20000000189c = 0);
    NONFAILING(*(uint64_t*)0x2000000018a4 = 0x200000001840);
    NONFAILING(*(uint8_t*)0x200000001840 = 0x40);
    NONFAILING(*(uint8_t*)0x200000001841 = 5);
    NONFAILING(*(uint32_t*)0x200000001842 = 1);
    NONFAILING(memset((void*)0x200000001846, 163, 1));
    NONFAILING(
        syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0x200000001880));
    break;
  case 8:
    //  syz_usb_control_io$rtl8150 arguments: [
    //    fd: fd_usb_rtl8150 (resource)
    //    descs: nil
    //    resps: nil
    //  ]
    NONFAILING(syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0));
    break;
  case 9:
    //  syz_usb_control_io$rtl8150 arguments: [
    //    fd: fd_usb_rtl8150 (resource)
    //    descs: nil
    //    resps: nil
    //  ]
    NONFAILING(syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0));
    break;
  case 10:
    //  syz_usb_control_io$rtl8150 arguments: [
    //    fd: fd_usb_rtl8150 (resource)
    //    descs: nil
    //    resps: nil
    //  ]
    NONFAILING(syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0));
    break;
  case 11:
    //  syz_usb_control_io arguments: [
    //    fd: fd_usb (resource)
    //    descs: nil
    //    resps: nil
    //  ]
    NONFAILING(syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0));
    break;
  case 12:
    //  syz_usb_control_io$rtl8150 arguments: [
    //    fd: fd_usb_rtl8150 (resource)
    //    descs: nil
    //    resps: ptr[in, vusb_responses_rtl8150] {
    //      vusb_responses_rtl8150 {
    //        len: len = 0x2c (4 bytes)
    //        generic: nil
    //        USB_REQ_GET_INTERFACE: nil
    //        USB_REQ_GET_CONFIGURATION: nil
    //        RTL8150_REQ_GET_REGS: nil
    //        RTL8150_REQ_SET_REGS: ptr[in, vusb_response_t[RTL8150_REQT_WRITE,
    //        RTL8150_REQ_SET_REGS, array[int8, 0:6]]] {
    //          vusb_response_t[RTL8150_REQT_WRITE, RTL8150_REQ_SET_REGS,
    //          array[int8, 0:6]] {
    //            type: const = 0x40 (1 bytes)
    //            req: const = 0x5 (1 bytes)
    //            len: bytesize = 0x2 (4 bytes)
    //            data: buffer: {ed c7} (length 0x2)
    //          }
    //        }
    //      }
    //    }
    //  ]
    NONFAILING(*(uint32_t*)0x200000004000 = 0x2c);
    NONFAILING(*(uint64_t*)0x200000004004 = 0);
    NONFAILING(*(uint64_t*)0x20000000400c = 0);
    NONFAILING(*(uint64_t*)0x200000004014 = 0);
    NONFAILING(*(uint64_t*)0x20000000401c = 0);
    NONFAILING(*(uint64_t*)0x200000004024 = 0x200000003fc0);
    NONFAILING(*(uint8_t*)0x200000003fc0 = 0x40);
    NONFAILING(*(uint8_t*)0x200000003fc1 = 5);
    NONFAILING(*(uint32_t*)0x200000003fc2 = 2);
    NONFAILING(memcpy((void*)0x200000003fc6, "\xed\xc7", 2));
    NONFAILING(
        syz_usb_control_io(/*fd=*/r[0], /*descs=*/0, /*resps=*/0x200000004000));
    break;
  case 13:
    //  openat$vim2m arguments: [
    //    fd: const = 0xffffffffffffff9c (8 bytes)
    //    file: nil
    //    flags: const = 0x2 (4 bytes)
    //    mode: const = 0x0 (2 bytes)
    //  ]
    //  returns fd_vim2m
    syscall(__NR_openat, /*fd=*/0xffffffffffffff9cul, /*file=*/0ul, /*flags=*/2,
            /*mode=*/0);
    break;
  case 14:
    //  syz_genetlink_get_family_id$ethtool arguments: [
    //    name: nil
    //    fd: sock_nl_generic (resource)
    //  ]
    //  returns genl_ethtool_family_id
    NONFAILING(syz_genetlink_get_family_id(/*name=*/0, /*fd=*/-1));
    break;
  case 15:
    //  socketpair$unix arguments: [
    //    domain: const = 0x1 (8 bytes)
    //    type: unix_socket_type = 0x5 (8 bytes)
    //    proto: const = 0x0 (4 bytes)
    //    fds: ptr[out, unix_pair] {
    //      unix_pair {
    //        fd0: sock_unix (resource)
    //        fd1: sock_unix (resource)
    //      }
    //    }
    //  ]
    res = syscall(__NR_socketpair, /*domain=*/1ul, /*type=SOCK_SEQPACKET*/ 5ul,
                  /*proto=*/0, /*fds=*/0x200000000180ul);
    if (res != -1)
      NONFAILING(r[1] = *(uint32_t*)0x200000000184);
    break;
  case 16:
    //  sendmmsg$unix arguments: [
    //    fd: sock_unix (resource)
    //    mmsg: ptr[in, array[send_mmsghdr_un]] {
    //      array[send_mmsghdr_un] {
    //      }
    //    }
    //    vlen: len = 0x318 (8 bytes)
    //    f: send_flags = 0x0 (8 bytes)
    //  ]
    syscall(__NR_sendmmsg, /*fd=*/r[1], /*mmsg=*/0x2000000bd000ul,
            /*vlen=*/0x318ul, /*f=*/0ul);
    break;
  }
}
int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x1ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x1000000ul,
          /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/ 7ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200001000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  setup_sysctl();
  const char* reason;
  (void)reason;
  install_segv_handler();
  for (procid = 0; procid < 4; procid++) {
    if (fork() == 0) {
      use_temporary_dir();
      loop();
    }
  }
  sleep(1000000);
  return 0;
}
