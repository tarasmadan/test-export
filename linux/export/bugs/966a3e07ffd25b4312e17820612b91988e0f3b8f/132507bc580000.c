// https://syzkaller.appspot.com/bug?id=966a3e07ffd25b4312e17820612b91988e0f3b8f
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

uint64_t r[2] = {0xffffffffffffffff, 0xffffffffffffffff};

int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x1ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x1000000ul,
          /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/ 7ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200001000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  const char* reason;
  (void)reason;
  intptr_t res = 0;
  if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
  }
  //  socket$nl_netfilter arguments: [
  //    domain: const = 0x10 (8 bytes)
  //    type: const = 0x3 (8 bytes)
  //    proto: const = 0xc (4 bytes)
  //  ]
  //  returns sock_nl_netfilter
  res = syscall(__NR_socket, /*domain=*/0x10ul, /*type=*/3ul, /*proto=*/0xc);
  if (res != -1)
    r[0] = res;
  //  sendmsg$NFT_BATCH arguments: [
  //    fd: sock_nl_netfilter (resource)
  //    msg: ptr[in, msghdr_netlink[nft_batch_msg]] {
  //      msghdr_netlink[nft_batch_msg] {
  //        addr: nil
  //        addrlen: len = 0x0 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //        vec: ptr[in, iovec[in, nft_batch_msg]] {
  //          iovec[in, nft_batch_msg] {
  //            addr: ptr[inout, array[ANYUNION]] {
  //              array[ANYUNION] {
  //                union ANYUNION {
  //                  ANYBLOB: buffer: {14 00 00 00 10 00 01 00 00 00 00 00 00
  //                  00 00 00 00 00 00 0a 20 00 00 00 00 0a 01 03 00 00 00 00
  //                  00 00 00 00 01 00 00 00 09 00 01 00 73 79 7a 30 00 00 00
  //                  00 40 00 00 00 03 0a 01 02 00 00 00 00 00 00 00 00 01 00
  //                  00 00 09 00 03 00 73 79 7a 32 00 00 00 00 14 00 04 80 08
  //                  00 02 40 32 65 65 a7 08 00 01 40 00 00 00 00 09 00 01 00
  //                  73 79 7a 30 00 00 00 00 48 00 00 00 06 0a 01 04 00 00 00
  //                  00 00 00 00 00 01 00 00 00 08 00 0b 40 00 00 00 00 09 00
  //                  01 00 73 79 7a 30 00 00 00 00 20 00 04 80 1c 00 01 80 0b
  //                  00 01 00 72 65 6a 65 63 74 00 00 0c 00 02 80 08 00 01 40
  //                  00 00 00 01 14 00 00 00 11 00 01} (length 0xc3)
  //                }
  //              }
  //            }
  //            len: len = 0xd0 (8 bytes)
  //          }
  //        }
  //        vlen: const = 0x1 (8 bytes)
  //        ctrl: const = 0x0 (8 bytes)
  //        ctrllen: const = 0x0 (8 bytes)
  //        f: send_flags = 0x0 (4 bytes)
  //        pad = 0x0 (4 bytes)
  //      }
  //    }
  //    f: send_flags = 0x0 (8 bytes)
  //  ]
  *(uint64_t*)0x2000000000c0 = 0;
  *(uint32_t*)0x2000000000c8 = 0;
  *(uint64_t*)0x2000000000d0 = 0x200000000040;
  *(uint64_t*)0x200000000040 = 0x2000000003c0;
  memcpy(
      (void*)0x2000000003c0,
      "\x14\x00\x00\x00\x10\x00\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
      "\x00\x0a\x20\x00\x00\x00\x00\x0a\x01\x03\x00\x00\x00\x00\x00\x00\x00\x00"
      "\x01\x00\x00\x00\x09\x00\x01\x00\x73\x79\x7a\x30\x00\x00\x00\x00\x40\x00"
      "\x00\x00\x03\x0a\x01\x02\x00\x00\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00"
      "\x09\x00\x03\x00\x73\x79\x7a\x32\x00\x00\x00\x00\x14\x00\x04\x80\x08\x00"
      "\x02\x40\x32\x65\x65\xa7\x08\x00\x01\x40\x00\x00\x00\x00\x09\x00\x01\x00"
      "\x73\x79\x7a\x30\x00\x00\x00\x00\x48\x00\x00\x00\x06\x0a\x01\x04\x00\x00"
      "\x00\x00\x00\x00\x00\x00\x01\x00\x00\x00\x08\x00\x0b\x40\x00\x00\x00\x00"
      "\x09\x00\x01\x00\x73\x79\x7a\x30\x00\x00\x00\x00\x20\x00\x04\x80\x1c\x00"
      "\x01\x80\x0b\x00\x01\x00\x72\x65\x6a\x65\x63\x74\x00\x00\x0c\x00\x02\x80"
      "\x08\x00\x01\x40\x00\x00\x00\x01\x14\x00\x00\x00\x11\x00\x01",
      195);
  *(uint64_t*)0x200000000048 = 0xd0;
  *(uint64_t*)0x2000000000d8 = 1;
  *(uint64_t*)0x2000000000e0 = 0;
  *(uint64_t*)0x2000000000e8 = 0;
  *(uint32_t*)0x2000000000f0 = 0;
  syscall(__NR_sendmsg, /*fd=*/r[0], /*msg=*/0x2000000000c0ul, /*f=*/0ul);
  //  socket$inet6_tcp arguments: [
  //    domain: const = 0xa (8 bytes)
  //    type: const = 0x1 (8 bytes)
  //    proto: const = 0x0 (4 bytes)
  //  ]
  //  returns sock_tcp6
  res = syscall(__NR_socket, /*domain=*/0xaul, /*type=*/1ul, /*proto=*/0);
  if (res != -1)
    r[1] = res;
  //  sendto$inet6 arguments: [
  //    fd: sock_in6 (resource)
  //    buf: nil
  //    len: len = 0x0 (8 bytes)
  //    f: send_flags = 0x20008800 (8 bytes)
  //    addr: ptr[in, sockaddr_in6] {
  //      sockaddr_in6 {
  //        family: const = 0xa (2 bytes)
  //        port: int16be = 0x2 (2 bytes)
  //        flow: int32be = 0x2 (4 bytes)
  //        addr: union ipv6_addr {
  //          empty: ipv6_addr_empty {
  //            a0: buffer: {00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
  //            (length 0x10)
  //          }
  //        }
  //        scope: int32 = 0x0 (4 bytes)
  //      }
  //    }
  //    addrlen: len = 0x1c (8 bytes)
  //  ]
  *(uint16_t*)0x2000000001c0 = 0xa;
  *(uint16_t*)0x2000000001c2 = htobe16(2);
  *(uint32_t*)0x2000000001c4 = htobe32(2);
  memset((void*)0x2000000001c8, 0, 16);
  *(uint32_t*)0x2000000001d8 = 0;
  syscall(__NR_sendto, /*fd=*/r[1], /*buf=*/0ul, /*len=*/0ul,
          /*f=MSG_FASTOPEN|MSG_MORE|MSG_CONFIRM*/ 0x20008800ul,
          /*addr=*/0x2000000001c0ul, /*addrlen=*/0x1cul);
  return 0;
}
