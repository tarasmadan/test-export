// https://syzkaller.appspot.com/bug?id=c527e299c2b876c3dc57be457c8728ddd938581c
// autogenerated by syzkaller (https://github.com/google/syzkaller)

#define _GNU_SOURCE

#include <endian.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/syscall.h>
#include <sys/types.h>
#include <unistd.h>

#ifndef __NR_bpf
#define __NR_bpf 321
#endif

#define BITMASK(bf_off, bf_len) (((1ull << (bf_len)) - 1) << (bf_off))
#define STORE_BY_BITMASK(type, htobe, addr, val, bf_off, bf_len)               \
  *(type*)(addr) =                                                             \
      htobe((htobe(*(type*)(addr)) & ~BITMASK((bf_off), (bf_len))) |           \
            (((type)(val) << (bf_off)) & BITMASK((bf_off), (bf_len))))

uint64_t r[1] = {0xffffffffffffffff};

int main(void)
{
  syscall(__NR_mmap, /*addr=*/0x1ffffffff000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200000000000ul, /*len=*/0x1000000ul,
          /*prot=PROT_WRITE|PROT_READ|PROT_EXEC*/ 7ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  syscall(__NR_mmap, /*addr=*/0x200001000000ul, /*len=*/0x1000ul, /*prot=*/0ul,
          /*flags=MAP_FIXED|MAP_ANONYMOUS|MAP_PRIVATE*/ 0x32ul,
          /*fd=*/(intptr_t)-1, /*offset=*/0ul);
  const char* reason;
  (void)reason;
  intptr_t res = 0;
  if (write(1, "executing program\n", sizeof("executing program\n") - 1)) {
  }
  //  bpf$MAP_CREATE arguments: [
  //    cmd: const = 0x100000000000000 (8 bytes)
  //    arg: ptr[inout, array[ANYUNION]] {
  //      array[ANYUNION] {
  //        union ANYUNION {
  //          ANYBLOB: buffer: {0a 00 00 00 16 00 00 00 b3 00 00 00 7f} (length
  //          0xd)
  //        }
  //      }
  //    }
  //    size: len = 0x48 (8 bytes)
  //  ]
  //  returns fd_bpf_map
  memcpy((void*)0x200000001800,
         "\x0a\x00\x00\x00\x16\x00\x00\x00\xb3\x00\x00\x00\x7f", 13);
  res = syscall(__NR_bpf, /*cmd=*/0x100000000000000ul, /*arg=*/0x200000001800ul,
                /*size=*/0x48ul);
  if (res != -1)
    r[0] = res;
  //  bpf$BPF_PROG_RAW_TRACEPOINT_LOAD arguments: [
  //    cmd: const = 0x5 (8 bytes)
  //    arg: ptr[in, bpf_prog_t[flags[bpf_raw_tracepoint_prog_types, int32],
  //    const[0, int32], const[0, int32], const[0, int32]]] {
  //      bpf_prog_t[flags[bpf_raw_tracepoint_prog_types, int32], const[0,
  //      int32], const[0, int32], const[0, int32]] {
  //        type: bpf_raw_tracepoint_prog_types = 0x11 (4 bytes)
  //        ninsn: bytesize8 = 0xb (4 bytes)
  //        insns: ptr[in, bpf_instructions] {
  //          union bpf_instructions {
  //            framed: bpf_framed_program {
  //              initr0: bpf_insn_init_r0 {
  //                code: const = 0x18 (1 bytes)
  //                dst: const = 0x3 (0 bytes)
  //                src: const = 0x0 (1 bytes)
  //                off: const = 0x0 (2 bytes)
  //                imm: int32 = 0xfffffffe (4 bytes)
  //                code2: const = 0x0 (1 bytes)
  //                regs2: const = 0x0 (1 bytes)
  //                off2: const = 0x0 (2 bytes)
  //                imm2: int32 = 0x0 (4 bytes)
  //              }
  //              body: array[bpf_insn] {
  //                union bpf_insn {
  //                  func: bpf_insn_call_func {
  //                    code: const = 0x85 (1 bytes)
  //                    dst: const = 0x0 (0 bytes)
  //                    src: const = 0x1 (1 bytes)
  //                    off: const = 0x0 (2 bytes)
  //                    func: int32 = 0x6 (4 bytes)
  //                  }
  //                }
  //                union bpf_insn {
  //                  map_fd: bpf_insn_map_fd_t[flags[bpf_reg, int8:4],
  //                  fd_bpf_map] {
  //                    code: const = 0x18 (1 bytes)
  //                    dst: bpf_reg = 0x0 (0 bytes)
  //                    src: const = 0x1 (1 bytes)
  //                    off: const = 0x0 (2 bytes)
  //                    imm: fd_bpf_map (resource)
  //                    code2: const = 0x0 (1 bytes)
  //                    regs2: const = 0x0 (1 bytes)
  //                    off2: const = 0x0 (2 bytes)
  //                    imm2: const = 0x0 (4 bytes)
  //                  }
  //                }
  //                union bpf_insn {
  //                  generic: bpf_insn_generic {
  //                    code: int8 = 0x87 (1 bytes)
  //                    dst: int8 = 0x0 (0 bytes)
  //                    src: int8 = 0x0 (1 bytes)
  //                    off: int16 = 0x0 (2 bytes)
  //                    imm: int32 = 0x0 (4 bytes)
  //                  }
  //                }
  //                union bpf_insn {
  //                  initr0: bpf_insn_init_r0 {
  //                    code: const = 0x18 (1 bytes)
  //                    dst: const = 0x0 (0 bytes)
  //                    src: const = 0x0 (1 bytes)
  //                    off: const = 0x0 (2 bytes)
  //                    imm: int32 = 0x0 (4 bytes)
  //                    code2: const = 0x0 (1 bytes)
  //                    regs2: const = 0x0 (1 bytes)
  //                    off2: const = 0x0 (2 bytes)
  //                    imm2: int32 = 0x0 (4 bytes)
  //                  }
  //                }
  //                union bpf_insn {
  //                  exit: bpf_insn_exit {
  //                    code: const = 0x95 (1 bytes)
  //                    regs: const = 0x0 (1 bytes)
  //                    off: const = 0x0 (2 bytes)
  //                    imm: const = 0x0 (4 bytes)
  //                  }
  //                }
  //                union bpf_insn {
  //                  alu: bpf_insn_alu_t[bpf_alu_insn, bpf_alu_source,
  //                  bpf_alu_op, flags[bpf_reg, int8:4], flags[bpf_reg,
  //                  int8:4], flags[bpf_insn_offsets, int16],
  //                  flags[bpf_insn_immediates, int32]] {
  //                    code_class: bpf_alu_insn = 0x7 (0 bytes)
  //                    code_s: bpf_alu_source = 0x0 (0 bytes)
  //                    code_op: bpf_alu_op = 0x2 (1 bytes)
  //                    dst: bpf_reg = 0x3 (0 bytes)
  //                    src: bpf_reg = 0x0 (1 bytes)
  //                    off: bpf_insn_offsets = 0x0 (2 bytes)
  //                    imm: bpf_insn_immediates = 0x0 (4 bytes)
  //                  }
  //                }
  //              }
  //              exit: bpf_insn_exit {
  //                code: const = 0x95 (1 bytes)
  //                regs: const = 0x0 (1 bytes)
  //                off: const = 0x0 (2 bytes)
  //                imm: const = 0x0 (4 bytes)
  //              }
  //            }
  //          }
  //        }
  //        license: ptr[in, buffer] {
  //          buffer: {47 50 4c 00} (length 0x4)
  //        }
  //        loglev: int32 = 0x1 (4 bytes)
  //        logsize: len = 0x0 (4 bytes)
  //        log: nil
  //        kern_version: bpf_kern_version = 0x40f00 (4 bytes)
  //        flags: bpf_prog_load_flags = 0x0 (4 bytes)
  //        prog_name: buffer: {00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00}
  //        (length 0x10) prog_ifindex: ifindex (resource) expected_attach_type:
  //        const = 0x0 (4 bytes) btf_fd: fd_btf (resource) func_info_rec_size:
  //        const = 0x8 (4 bytes) func_info: nil func_info_cnt: len = 0x0 (4
  //        bytes) line_info_rec_size: const = 0x10 (4 bytes) line_info: nil
  //        line_info_cnt: len = 0x0 (4 bytes)
  //        attach_btf_id: const = 0x0 (4 bytes)
  //        attach_prog_fd: const = 0x0 (4 bytes)
  //        core_relo_cnt: len = 0x0 (4 bytes)
  //        fd_array: nil
  //        core_relos: nil
  //        core_relo_rec_size: const = 0x10 (4 bytes)
  //        log_true_size: int32 = 0x0 (4 bytes)
  //        prog_token_fd: union
  //        _bpf_prog_t[flags[bpf_raw_tracepoint_prog_types, int32], const[0,
  //        int32], const[0, int32], const[0, int32]]_prog_token_fd_wrapper {
  //          void: buffer: {} (length 0x0)
  //        }
  //        pad: union _bpf_prog_t[flags[bpf_raw_tracepoint_prog_types, int32],
  //        const[0, int32], const[0, int32], const[0, int32]]_pad_wrapper {
  //          value: const = 0x0 (4 bytes)
  //        }
  //      }
  //    }
  //    size: len = 0x94 (8 bytes)
  //  ]
  //  returns fd_bpf_prog_raw_tracepoint
  *(uint32_t*)0x200000000100 = 0x11;
  *(uint32_t*)0x200000000104 = 0xb;
  *(uint64_t*)0x200000000108 = 0x200000000080;
  *(uint8_t*)0x200000000080 = 0x18;
  STORE_BY_BITMASK(uint8_t, , 0x200000000081, 3, 0, 4);
  STORE_BY_BITMASK(uint8_t, , 0x200000000081, 0, 4, 4);
  *(uint16_t*)0x200000000082 = 0;
  *(uint32_t*)0x200000000084 = 0xfffffffe;
  *(uint8_t*)0x200000000088 = 0;
  *(uint8_t*)0x200000000089 = 0;
  *(uint16_t*)0x20000000008a = 0;
  *(uint32_t*)0x20000000008c = 0;
  *(uint8_t*)0x200000000090 = 0x85;
  STORE_BY_BITMASK(uint8_t, , 0x200000000091, 0, 0, 4);
  STORE_BY_BITMASK(uint8_t, , 0x200000000091, 1, 4, 4);
  *(uint16_t*)0x200000000092 = 0;
  *(uint32_t*)0x200000000094 = 6;
  *(uint8_t*)0x200000000098 = 0x18;
  STORE_BY_BITMASK(uint8_t, , 0x200000000099, 0, 0, 4);
  STORE_BY_BITMASK(uint8_t, , 0x200000000099, 1, 4, 4);
  *(uint16_t*)0x20000000009a = 0;
  *(uint32_t*)0x20000000009c = r[0];
  *(uint8_t*)0x2000000000a0 = 0;
  *(uint8_t*)0x2000000000a1 = 0;
  *(uint16_t*)0x2000000000a2 = 0;
  *(uint32_t*)0x2000000000a4 = 0;
  *(uint8_t*)0x2000000000a8 = 0x87;
  STORE_BY_BITMASK(uint8_t, , 0x2000000000a9, 0, 0, 4);
  STORE_BY_BITMASK(uint8_t, , 0x2000000000a9, 0, 4, 4);
  *(uint16_t*)0x2000000000aa = 0;
  *(uint32_t*)0x2000000000ac = 0;
  *(uint8_t*)0x2000000000b0 = 0x18;
  STORE_BY_BITMASK(uint8_t, , 0x2000000000b1, 0, 0, 4);
  STORE_BY_BITMASK(uint8_t, , 0x2000000000b1, 0, 4, 4);
  *(uint16_t*)0x2000000000b2 = 0;
  *(uint32_t*)0x2000000000b4 = 0;
  *(uint8_t*)0x2000000000b8 = 0;
  *(uint8_t*)0x2000000000b9 = 0;
  *(uint16_t*)0x2000000000ba = 0;
  *(uint32_t*)0x2000000000bc = 0;
  *(uint8_t*)0x2000000000c0 = 0x95;
  *(uint8_t*)0x2000000000c1 = 0;
  *(uint16_t*)0x2000000000c2 = 0;
  *(uint32_t*)0x2000000000c4 = 0;
  STORE_BY_BITMASK(uint8_t, , 0x2000000000c8, 7, 0, 3);
  STORE_BY_BITMASK(uint8_t, , 0x2000000000c8, 0, 3, 1);
  STORE_BY_BITMASK(uint8_t, , 0x2000000000c8, 2, 4, 4);
  STORE_BY_BITMASK(uint8_t, , 0x2000000000c9, 3, 0, 4);
  STORE_BY_BITMASK(uint8_t, , 0x2000000000c9, 0, 4, 4);
  *(uint16_t*)0x2000000000ca = 0;
  *(uint32_t*)0x2000000000cc = 0;
  *(uint8_t*)0x2000000000d0 = 0x95;
  *(uint8_t*)0x2000000000d1 = 0;
  *(uint16_t*)0x2000000000d2 = 0;
  *(uint32_t*)0x2000000000d4 = 0;
  *(uint64_t*)0x200000000110 = 0x200000000000;
  memcpy((void*)0x200000000000, "GPL\000", 4);
  *(uint32_t*)0x200000000118 = 1;
  *(uint32_t*)0x20000000011c = 0;
  *(uint64_t*)0x200000000120 = 0;
  *(uint32_t*)0x200000000128 = 0x40f00;
  *(uint32_t*)0x20000000012c = 0;
  memset((void*)0x200000000130, 0, 16);
  *(uint32_t*)0x200000000140 = 0;
  *(uint32_t*)0x200000000144 = 0;
  *(uint32_t*)0x200000000148 = -1;
  *(uint32_t*)0x20000000014c = 8;
  *(uint64_t*)0x200000000150 = 0;
  *(uint32_t*)0x200000000158 = 0;
  *(uint32_t*)0x20000000015c = 0x10;
  *(uint64_t*)0x200000000160 = 0;
  *(uint32_t*)0x200000000168 = 0;
  *(uint32_t*)0x20000000016c = 0;
  *(uint32_t*)0x200000000170 = 0;
  *(uint32_t*)0x200000000174 = 0;
  *(uint64_t*)0x200000000178 = 0;
  *(uint64_t*)0x200000000180 = 0;
  *(uint32_t*)0x200000000188 = 0x10;
  *(uint32_t*)0x20000000018c = 0;
  *(uint32_t*)0x200000000190 = 0;
  syscall(__NR_bpf, /*cmd=*/5ul, /*arg=*/0x200000000100ul, /*size=*/0x94ul);
  return 0;
}
